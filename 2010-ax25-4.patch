Index: src/lib/libc/net/Makefile.inc
===================================================================
--- src.orig/lib/libc/net/Makefile.inc
+++ src/lib/libc/net/Makefile.inc
@@ -5,7 +5,7 @@
 
 CFLAGS+=-DRESOLVSORT
 
-SRCS+=	base64.c ethers.c freeaddrinfo.c \
+SRCS+=	ax25.c base64.c ethers.c freeaddrinfo.c \
 	gai_strerror.c getaddrinfo.c gethostnamadr.c \
 	getifaddrs.c getnameinfo.c getnetent.c \
 	getnetnamadr.c getpeereid.c getproto.c getprotoent.c getprotoname.c \
Index: src/lib/libc/net/ax25.c
===================================================================
--- /dev/null
+++ src/lib/libc/net/ax25.c
@@ -0,0 +1,74 @@
+#include <ctype.h>
+#include <string.h>
+#include <strings.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <sys/types.h>
+#include <netax25/if_ax25.h>
+
+/*
+ * Convert the network representation of an AX.25 address to a human readable
+ * callsign and SSID. This function is not thread safe, as it returns the
+ * result in a statically assigned buffer.
+ */
+char *
+ax25_ntoa(struct ax25_addr *axp)
+{
+	static char buf[10];
+	int i, ssid;
+	ssid = (axp->ax25_addr_octet[6] & AX25_SSID_MASK) >> 1;
+	bzero(buf, 10);
+	for (i = 0; i < 6; i++) {
+		if (axp->ax25_addr_octet[i] == 0x40)
+			break;
+		buf[i] = axp->ax25_addr_octet[i] >> 1;
+	}
+	if (ssid == 0) {
+		buf[i] = '\0';
+	} else {
+		snprintf(&buf[i], 10, "-%d", ssid);
+	}
+	return buf;
+}
+
+/*
+ * Convert a human readable callsign and SSID to the network representation of
+ * an AX.25 address. This function is not thread safe, as it returns the result
+ * in a statically assigned buffer.
+ */
+struct ax25_addr *
+ax25_aton(const char *s)
+{
+	static struct ax25_addr ax;
+	char ssid[3];
+	int i;
+	memcpy(&ax, "\x40\x40\x40\x40\x40\x40\x00", sizeof(struct ax25_addr));
+	for (i = 0; ; i++) {
+		if (s[i] == '\0') {
+			ax.ax25_addr_octet[6] = 0;
+			break;
+		}
+		if (s[i] == '-') {
+			if (isdigit(s[++i])) {
+				bzero(ssid, 3);
+				ssid[0] = s[i];
+				if (isdigit(s[++i]))
+					ssid[1] = s[i];
+				ax.ax25_addr_octet[6] = atoi(ssid) << 1;
+				if ((ax.ax25_addr_octet[6] & ~AX25_SSID_MASK) != 0) {
+					/* non AX.25 SSID */
+					return NULL;
+				}
+				break;
+			} else {
+				/* callsign is malformed */
+				return NULL;
+			}
+		}
+		ax.ax25_addr_octet[i] = toupper(s[i]) << 1;
+	}
+	ax.ax25_addr_octet[6] |= AX25_RESERVED_MASK;
+	return &ax;
+}
+
Index: src/sys/netax25/if_ax25.h
===================================================================
--- /dev/null
+++ src/sys/netax25/if_ax25.h
@@ -0,0 +1,113 @@
+/*	$OpenBSD: if_ether.h,v 1.76 2019/07/17 16:46:18 mpi Exp $	*/
+/*	$NetBSD: if_ether.h,v 1.22 1996/05/11 13:00:00 mycroft Exp $	*/
+
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if_ether.h	8.1 (Berkeley) 6/10/93
+ */
+
+#ifndef _NETINET_IF_AX25_H_
+#define _NETINET_IF_AX25_H_
+
+/*
+ * Some basic AX.25 constants.
+ */
+#define	AX25_ADDR_LEN		7	/* AX.25 address length			*/
+#define AX25_CNTL_LEN		1	/* AX.25 control field length		*/
+#define AX25_PID_LEN		1	/* AX.25 PID field length		*/
+#define AX25_HDR_MIN_LEN	((AX25_ADDR_LEN * 2) + AX25_CNTL_LEN + AX25_PID_LEN)
+#define AX25_HDR_MAX_LEN	((AX25_ADDR_LEN * 10) + AX25_CNTL_LEN + AX25_PID_LEN)
+#define AX25_MAX_DIGIS		8	/* Maximum number of digipeaters in path */
+
+/*
+ * The maximum supported AX.25 length and some space for encapsulation.
+ */
+#define AX25_MAX_HARDMTU_LEN	65435
+
+/*
+ * AX.25 address - 7 octets
+ */
+struct ax25_addr {
+	u_int8_t ax25_addr_octet[AX25_ADDR_LEN];
+};
+
+/*
+ * Bitmasks for final octet of address
+ */
+#define AX25_CR_MASK		0b10000000	/* Command/response bit */
+#define AX25_RESERVED_MASK	0b01100000	/* Reserved bits	*/
+#define AX25_SSID_MASK		0b00011110	/* SSID bits		*/
+#define AX25_LAST_MASK		0b00000001	/* Final address bit	*/
+
+//#include <netax25/protocols.h>
+
+#define	AX25_IS_BROADCAST(addr) \
+	(((addr)[0] == "Q" << 1 & (addr)[1] == "S" << 1 & \
+	  (addr)[2] == "T" << 1 & (addr)[3] == " " << 1 & \
+	  (addr)[4] == " " << 1 & (addr)[5] == " " << 1 & \
+	  (addr)[6] == 0))
+#define	AX25_IS_ANYADDR(addr)		\
+	(((addr)[0] == "A" << 1 & (addr)[1] == "N" << 1 & \
+	  (addr)[2] == "Y" << 1 & (addr)[3] == " " << 1 & \
+	  (addr)[4] == " " << 1 & (addr)[5] == " " << 1 & \
+	  (addr)[6] == 0))
+#define	AX25_IS_EQ(a1, a2)	(memcmp((a1), (a2), AX25_ADDR_LEN) == 0)
+
+#ifdef _KERNEL
+
+#include <net/if_var.h>	/* for "struct ifnet" */
+
+extern u_int8_t ax25broadcastaddr[AX25_ADDR_LEN];
+extern u_int8_t ax25anyaddr[AX25_ADDR_LEN];
+extern u_int8_t ax25nulladdr[AX25_ADDR_LEN];
+
+/*
+void	ax25_ifattach(struct ifnet *);
+void	ax25_ifdetach(struct ifnet *);
+int	ax25_ioctl(struct ifnet *, struct arpcom *, u_long, caddr_t);
+int	ax25_input(struct ifnet *, struct mbuf *, void *);
+int	ax25_resolve(struct ifnet *, struct mbuf *, struct sockaddr *,
+	    struct rtentry *, struct ax25_header *);
+struct mbuf *
+	ax25_encap(struct ifnet *, struct mbuf *, struct sockaddr *,
+	    struct rtentry *, int *);
+int	ax25_output(struct ifnet *, struct mbuf *, struct sockaddr *,
+	    struct rtentry *);
+char	*ax25_sprintf(u_char *);
+*/
+
+#else /* _KERNEL */
+
+__BEGIN_DECLS
+char *ax25_ntoa(struct ax25_addr *);
+struct ax25_addr *ax25_aton(const char *);
+__END_DECLS
+
+#endif /* _KERNEL */
+#endif /* _NETINET_IF_AX25_H_ */
Index: src/sys/netax25/if_ax25subr.c
===================================================================
--- /dev/null
+++ src/sys/netax25/if_ax25subr.c
@@ -0,0 +1,85 @@
+
+#include <sys/types.h>
+
+#include <netax25/if_ax25.h>
+
+u_int8_t ax25broadcastaddr[AX25_ADDR_LEN] =
+    { 'Q' << 1, 'S' << 1, 'T' << 1, ' ' << 1, ' ' << 1, ' ' << 1, 0 };
+u_int8_t ax25anyaddr[AX25_ADDR_LEN] =
+    { 'A' << 1, 'N' << 1, 'Y' << 1, ' ' << 1, ' ' << 1, ' ' << 1, 0 };
+u_int8_t ax25nulladdr[AX25_ADDR_LEN] =
+    { 'N' << 1, '0' << 1, 'C' << 1, 'A' << 1, 'L' << 1, 'L' << 1, 0 };
+
+/*
+ * Process a received AX.25 frame.
+ */
+int
+ax25_input(struct ifnet *ifp, struct mbuf *m, void cookie)
+{
+	/* Drop short frames */
+	if (m->m_len < AX25_MIN_HDR_LEN)
+		goto dropanyway;
+
+	/* TODO: do something with the packet in the future */
+
+dropanyway:
+	m_freem(m);
+	return 1;
+
+/*
+ * Perform common duties while attaching to interface list.
+ */
+void
+ax25_ifattach(struct ifnet *ifp)
+{
+	ifp->if_type = IFT_AX25;
+	ifp->if_addrlen = AX25_ADDR_LEN;
+	ifp->if_hdrlen = AX25_MAX_HDR_LEN;
+	ifp->if_mtu = ETHERMTU; /* TODO: think more */
+	/* TODO: set ifoutput */
+
+	if_ih_insert(ifp, ax25_input, NULL);
+
+	/* TODO: set hard mtu */
+
+	if_alloc_sadl(ifp);
+	memcpy(LLADDR(ifp->if_sadl), ax25nulladdr, ifp->if_addrlen);
+
+#if NBPFILTER > 0
+	bpfattach(&ifp->if_bpf, ifp, DLT_AX25, AX25_MAX_HDR_LEN);
+#endif
+}
+
+/*
+ * Perform common duties while detaching from the interface list.
+ */
+void
+ax25_ifdetach(struct ifnet *ifp)
+{
+	if_deactivate(ifp);
+
+	if_ih_remove(ifp, ax25_input, NULL);
+
+	KASSERT(SRPL_EMPTY_LOCKED(&ifp->if_inputs));
+}
+
+/*
+ * Convert AX25 address to printable (loggable) representation.
+ */
+char *
+ax25_sprintf(u_char *ap)
+{
+	int i, ssid;
+	static char ax25buf[AX25_ADDR_LEN + 3];
+	char *cp = ax25buf;
+	for (i = 0; i < AX25_ADDR_LEN - 1; i++) {
+		*cp++ = *ap++ >> 1;
+	}
+	*cp++ = '-';
+	ssid = *ap >> 1;
+	if (ssid > 9) {
+		*cp++ = '1';
+	}
+	*cp++ = '0' + (ssid % 10);
+	return ax25buf;
+}
Index: src/lib/libc/Symbols.list
===================================================================
--- src.orig/lib/libc/Symbols.list
+++ src/lib/libc/Symbols.list
@@ -1092,6 +1092,8 @@ _res
 _res_ext
 _res_opcodes
 _res_resultcodes
+ax25_aton
+ax25_ntoa
 dn_expand
 endhostent
 endnetent
