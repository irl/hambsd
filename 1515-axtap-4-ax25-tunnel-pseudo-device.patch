Index: src/sys/arch/amd64/amd64/conf.c
===================================================================
--- src.orig/sys/arch/amd64/amd64/conf.c
+++ src/sys/arch/amd64/amd64/conf.c
@@ -297,6 +297,7 @@ struct cdevsw	cdevsw[] =
 	cdev_pvbus_init(NPVBUS,pvbus),	/* 95: pvbus(4) control interface */
 	cdev_ipmi_init(NIPMI,ipmi),	/* 96: ipmi */
 	cdev_switch_init(NSWITCH,switch), /* 97: switch(4) control interface */
+	cdev_tun_init(NTUN,axtap),	/* 98: AX.25 network tunnel */
 };
 int	nchrdev = nitems(cdevsw);
 
Index: src/sys/net/if_tun.c
===================================================================
--- src.orig/sys/net/if_tun.c
+++ src/sys/net/if_tun.c
@@ -125,6 +125,14 @@ int	tapwrite(dev_t, struct uio *, int);
 int	tappoll(dev_t, int, struct proc *);
 int	tapkqfilter(dev_t, struct knote *);
 
+int	axtapopen(dev_t, int, int, struct proc *);
+int	axtapclose(dev_t, int, int, struct proc *);
+int	axtapioctl(dev_t, u_long, caddr_t, int, struct proc *);
+int	axtapread(dev_t, struct uio *, int);
+int	axtapwrite(dev_t, struct uio *, int);
+int	axtappoll(dev_t, int, struct proc *);
+int	axtapkqfilter(dev_t, struct knote *);
+
 int	tun_dev_open(struct tun_softc *, int, int, struct proc *);
 int	tun_dev_close(struct tun_softc *, int, int, struct proc *);
 int	tun_dev_ioctl(struct tun_softc *, u_long, caddr_t, int, struct proc *);
@@ -139,10 +147,12 @@ int	tun_output(struct ifnet *, struct mb
 	    struct rtentry *);
 int	tun_clone_create(struct if_clone *, int);
 int	tap_clone_create(struct if_clone *, int);
+int	axtap_clone_create(struct if_clone *, int);
 int	tun_create(struct if_clone *, int, int);
 int	tun_clone_destroy(struct ifnet *);
 static inline struct	tun_softc *tun_lookup(int);
 static inline struct	tun_softc *tap_lookup(int);
+static inline struct	tun_softc *axtap_lookup(int);
 void	tun_wakeup(struct tun_softc *);
 int	tun_init(struct tun_softc *);
 void	tun_start(struct ifnet *);
@@ -160,6 +170,7 @@ struct filterops tunwrite_filtops =
 
 LIST_HEAD(, tun_softc) tun_softc_list;
 LIST_HEAD(, tun_softc) tap_softc_list;
+LIST_HEAD(, tun_softc) axtap_softc_list;
 
 struct if_clone tun_cloner =
     IF_CLONE_INITIALIZER("tun", tun_clone_create, tun_clone_destroy);
@@ -167,13 +178,18 @@ struct if_clone tun_cloner =
 struct if_clone tap_cloner =
     IF_CLONE_INITIALIZER("tap", tap_clone_create, tun_clone_destroy);
 
+struct if_clone axtap_cloner =
+    IF_CLONE_INITIALIZER("axtap", axtap_clone_create, tun_clone_destroy);
+
 void
 tunattach(int n)
 {
 	LIST_INIT(&tun_softc_list);
 	LIST_INIT(&tap_softc_list);
+	LIST_INIT(&axtap_softc_list);
 	if_clone_attach(&tun_cloner);
 	if_clone_attach(&tap_cloner);
+	if_clone_attach(&axtap_cloner);
 #ifdef PIPEX
 	pipex_init();
 #endif
@@ -192,6 +208,12 @@ tap_clone_create(struct if_clone *ifc, i
 }
 
 int
+axtap_clone_create(struct if_clone *ifc, int unit)
+{
+	return (tun_create(ifc, unit, TUN_AX25));
+}
+
+int
 tun_create(struct if_clone *ifc, int unit, int flags)
 {
 	struct tun_softc	*tp;
@@ -216,7 +238,7 @@ tun_create(struct if_clone *ifc, int uni
 	ifp->if_link_state = LINK_STATE_DOWN;
 	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
 
-	if ((flags & TUN_LAYER2) == 0) {
+	if ((flags & (TUN_LAYER2 | TUN_AX25)) == 0) {
 		tp->tun_flags &= ~TUN_LAYER2;
 		ifp->if_mtu = ETHERMTU;
 		ifp->if_flags = (IFF_POINTOPOINT|IFF_MULTICAST);
@@ -230,6 +252,22 @@ tun_create(struct if_clone *ifc, int uni
 		bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
 #endif
 		LIST_INSERT_HEAD(&tun_softc_list, tp, entry);
+	} else if (flags & TUN_AX25) {
+		tp->tun_flags |= TUN_AX25;
+		ifp->if_flags =
+		    (IFF_BROADCAST|IFF_MULTICAST);
+        	ifp->if_type = IFT_AX25;
+	        ifp->if_addrlen = sizeof(u_int8_t) * 7;
+	        ifp->if_hdrlen = 0;
+	        ifp->if_mtu = ETHERMTU;
+
+		if_attach(ifp);
+		if_alloc_sadl(ifp);
+#if NBPFILTER > 0
+		bpfattach(&ifp->if_bpf, ifp, DLT_AX25, 0);
+#endif
+
+		LIST_INSERT_HEAD(&axtap_softc_list, tp, entry);
 	} else {
 		tp->tun_flags |= TUN_LAYER2;
 		ether_fakeaddr(ifp);
@@ -244,7 +282,7 @@ tun_create(struct if_clone *ifc, int uni
 	}
 
 #ifdef PIPEX
-	if ((tp->tun_flags & TUN_LAYER2) == 0)
+	if ((tp->tun_flags & (TUN_LAYER2 | TUN_AX25)) == 0)
 		pipex_iface_init(&tp->pipex_iface, ifp);
 #endif
 
@@ -258,7 +296,7 @@ tun_clone_destroy(struct ifnet *ifp)
 	int			 s;
 
 #ifdef PIPEX
-	if ((tp->tun_flags & TUN_LAYER2) == 0)
+	if ((tp->tun_flags & (TUN_LAYER2 | TUN_AX25)) == 0)
 		pipex_iface_fini(&tp->pipex_iface);
 #endif
 	tun_wakeup(tp);
@@ -301,6 +339,17 @@ tap_lookup(int unit)
 	return (NULL);
 }
 
+static inline struct tun_softc *
+axtap_lookup(int unit)
+{
+	struct tun_softc *tp;
+
+	LIST_FOREACH(tp, &axtap_softc_list, entry)
+		if (tp->tun_unit == unit)
+			return (tp);
+	return (NULL);
+}
+
 /*
  * tunnel open - must be superuser & the device must be
  * configured in
@@ -352,6 +401,29 @@ tapopen(dev_t dev, int flag, int mode, s
 }
 
 int
+axtapopen(dev_t dev, int flag, int mode, struct proc *p)
+{
+	struct tun_softc *tp;
+	unsigned int rdomain = rtable_l2(p->p_p->ps_rtableid);
+
+	if ((tp = axtap_lookup(minor(dev))) == NULL) {	/* create on demand */
+		char	xname[IFNAMSIZ];
+		int	error;
+
+		snprintf(xname, sizeof(xname), "%s%d", "axtap", minor(dev));
+		error = if_clone_create(xname, rdomain);
+		if (error != 0)
+			return (error);
+
+		if ((tp = axtap_lookup(minor(dev))) == NULL)
+			return (ENXIO);
+		tp->tun_flags &= ~TUN_STAYUP;
+	}
+
+	return (tun_dev_open(tp, flag, mode, p));
+}
+
+int
 tun_dev_open(struct tun_softc *tp, int flag, int mode, struct proc *p)
 {
 	struct ifnet *ifp;
@@ -397,6 +469,16 @@ tapclose(dev_t dev, int flag, int mode,
 }
 
 int
+axtapclose(dev_t dev, int flag, int mode, struct proc *p)
+{
+	struct tun_softc	*tp;
+
+	if ((tp = axtap_lookup(minor(dev))) == NULL)
+		return (ENXIO);
+	return (tun_dev_close(tp, flag, mode, p));
+}
+
+int
 tun_dev_close(struct tun_softc *tp, int flag, int mode, struct proc *p)
 {
 	int			 error = 0;
@@ -543,6 +625,9 @@ tun_output(struct ifnet *ifp, struct mbu
 		return (EHOSTDOWN);
 	}
 
+	if (tp->tun_flags & TUN_AX25)
+		return (if_enqueue(ifp, m0));
+
 	if (tp->tun_flags & TUN_LAYER2)
 		return (ether_output(ifp, m0, dst, rt));
 
@@ -613,6 +698,16 @@ tapioctl(dev_t dev, u_long cmd, caddr_t
 }
 
 int
+axtapioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
+{
+	struct tun_softc *tp;
+
+	if ((tp = axtap_lookup(minor(dev))) == NULL)
+		return (ENXIO);
+	return (tun_dev_ioctl(tp, cmd, data, flag, p));
+}
+
+int
 tun_dev_ioctl(struct tun_softc *tp, u_long cmd, caddr_t data, int flag,
     struct proc *p)
 {
@@ -732,6 +827,16 @@ tapread(dev_t dev, struct uio *uio, int
 }
 
 int
+axtapread(dev_t dev, struct uio *uio, int ioflag)
+{
+	struct tun_softc *tp;
+
+	if ((tp = axtap_lookup(minor(dev))) == NULL)
+		return (ENXIO);
+	return (tun_dev_read(tp, uio, ioflag));
+}
+
+int
 tun_dev_read(struct tun_softc *tp, struct uio *uio, int ioflag)
 {
 	struct ifnet		*ifp = &tp->tun_if;
@@ -778,7 +883,7 @@ tun_dev_read(struct tun_softc *tp, struc
 		}
 	} while (m0 == NULL);
 
-	if (tp->tun_flags & TUN_LAYER2) {
+	if (tp->tun_flags & (TUN_LAYER2 | TUN_AX25)) {
 #if NBPFILTER > 0
 		if (ifp->if_bpf)
 			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
@@ -827,6 +932,16 @@ tapwrite(dev_t dev, struct uio *uio, int
 }
 
 int
+axtapwrite(dev_t dev, struct uio *uio, int ioflag)
+{
+	struct tun_softc *tp;
+
+	if ((tp = axtap_lookup(minor(dev))) == NULL)
+		return (ENXIO);
+	return (tun_dev_write(tp, uio, ioflag));
+}
+
+int
 tun_dev_write(struct tun_softc *tp, struct uio *uio, int ioflag)
 {
 	struct ifnet		*ifp;
@@ -861,7 +976,7 @@ tun_dev_write(struct tun_softc *tp, stru
 
 	top = NULL;
 	mp = &top;
-	if (tp->tun_flags & TUN_LAYER2) {
+	if (tp->tun_flags & (TUN_LAYER2 | TUN_AX25)) {
 		/*
 		 * Pad so that IP header is correctly aligned
 		 * this is necessary for all strict aligned architectures.
@@ -900,7 +1015,7 @@ tun_dev_write(struct tun_softc *tp, stru
 
 	top->m_pkthdr.len = tlen;
 
-	if (tp->tun_flags & TUN_LAYER2) {
+	if (tp->tun_flags & (TUN_LAYER2 | TUN_AX25)) {
 		struct mbuf_list ml = MBUF_LIST_INITIALIZER();
 
 		ml_enqueue(&ml, top);
@@ -978,6 +1093,16 @@ tappoll(dev_t dev, int events, struct pr
 }
 
 int
+axtappoll(dev_t dev, int events, struct proc *p)
+{
+	struct tun_softc *tp;
+
+	if ((tp = axtap_lookup(minor(dev))) == NULL)
+		return (POLLERR);
+	return (tun_dev_poll(tp, events, p));
+}
+
+int
 tun_dev_poll(struct tun_softc *tp, int events, struct proc *p)
 {
 	int			 revents;
@@ -1030,6 +1155,16 @@ tapkqfilter(dev_t dev, struct knote *kn)
 }
 
 int
+axtapkqfilter(dev_t dev, struct knote *kn)
+{
+	struct tun_softc *tp;
+
+	if ((tp = axtap_lookup(minor(dev))) == NULL)
+		return (ENXIO);
+	return (tun_dev_kqfilter(tp, kn));
+}
+
+int
 tun_dev_kqfilter(struct tun_softc *tp, struct knote *kn)
 {
 	int			 s;
@@ -1143,7 +1278,7 @@ tun_link_state(struct tun_softc *tp)
 	int link_state = LINK_STATE_DOWN;
 
 	if (tp->tun_flags & TUN_OPEN) {
-		if (tp->tun_flags & TUN_LAYER2)
+		if (tp->tun_flags & (TUN_LAYER2 | TUN_AX25))
 			link_state = LINK_STATE_FULL_DUPLEX;
 		else
 			link_state = LINK_STATE_UP;
Index: src/sys/net/if_tun.h
===================================================================
--- src.orig/sys/net/if_tun.h
+++ src/sys/net/if_tun.h
@@ -42,6 +42,7 @@
 #define TUN_BRDADDR	0x0200
 #define TUN_STAYUP	0x0400
 #define TUN_LAYER2	0x0800
+#define TUN_AX25	0x8000 /* HamBSD specific */
 
 #define	TUN_READY	(TUN_OPEN | TUN_INITED)
 
Index: src/sys/net/if_types.h
===================================================================
--- src.orig/sys/net/if_types.h
+++ src/sys/net/if_types.h
@@ -270,4 +270,7 @@
 #define IFT_PFLOW	0xf9		/* pflow */
 #define IFT_MBIM	0xfa		/* Mobile Broadband Interface Model */
 
+/* HamBSD types... even more badly handled than above */
+#define IFT_AX25	0xff		/* AX.25 Layer 2 */
+
 #endif /* _NET_IF_TYPES_H_ */
Index: src/sys/sys/conf.h
===================================================================
--- src.orig/sys/sys/conf.h
+++ src/sys/sys/conf.h
@@ -583,6 +583,7 @@ cdev_decl(pf);
 
 cdev_decl(tun);
 cdev_decl(tap);
+cdev_decl(axtap);
 cdev_decl(switch);
 cdev_decl(pppx);
 
Index: src/sys/net/bpf.c
===================================================================
--- src.orig/sys/net/bpf.c
+++ src/sys/net/bpf.c
@@ -181,6 +181,7 @@ bpf_movein(struct uio *uio, struct bpf_d
 		hlen = 0;
 		break;
 
+	case DLT_AX25:
 	case DLT_RAW:
 	case DLT_NULL:
 		sockp->sa_family = AF_UNSPEC;
