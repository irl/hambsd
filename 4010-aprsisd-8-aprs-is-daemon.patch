Index: src/usr.sbin/aprsisd/Makefile
===================================================================
--- /dev/null
+++ src/usr.sbin/aprsisd/Makefile
@@ -0,0 +1,7 @@
+#	$OpenBSD: Makefile,v 1.8 2015/03/11 14:59:04 deraadt Exp $
+
+PROG=	aprsisd
+SRCS=	aprsisd.c ax25.c
+MAN=	aprsisd.8
+
+.include <bsd.prog.mk>
Index: src/usr.sbin/aprsisd/aprsisd.8
===================================================================
--- /dev/null
+++ src/usr.sbin/aprsisd/aprsisd.8
@@ -0,0 +1,50 @@
+.Dd October 13, 2019
+.Dt APRSISD 8
+.Os
+.Sh NAME
+.Nm aprsisd
+.Nd APRS-IS daemon
+.Sh
+.Sh SYNOPSIS
+.Nm aprsisd
+.Op Fl D
+.Op Fl c Ar callsign
+.Op Fl f Ar filter
+.Op Fl p Ar password
+.Op Fl t Ar /dev/tapX
+server
+.Sh DESCRIPTION
+APRS-IS is an Internet-based network which inter-connects various APRS radio
+networks throughout the world (and space).
+The
+.Nm
+daemon works together with the kernel
+.Xr tap 4
+driver to establish a connection to an APRS-IS server and present it as a
+virtual network interface.
+.Nm
+can also authenticate to the server and set an optional filter.
+.Pp
+By default the callsign from
+.Xr mycallsign 5
+will be used.
+.Pp
+.Nm
+itself will not produce or consume packets.
+A separate application, for example
+.Xr aprsd 8 ,
+must be used for that purpose.
+.Sh DIAGNOSTICS
+.Sh SEE ALSO
+.Xr tun 4 ,
+.Xr mycallsign 5 ,
+.Xr aprsd 8
+.Sh HISTORY
+.Nm
+first appeared in HamBSD XXX.
+.Sh AUTHORS
+The
+.Nm
+daemon was written for the HamBSD project by
+.An Iain R. Learmonth Aq Mt irl@fsfe.org
+for the public domain.
Index: src/usr.sbin/aprsisd/aprsisd.c
===================================================================
--- /dev/null
+++ src/usr.sbin/aprsisd/aprsisd.c
@@ -0,0 +1,322 @@
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <err.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/event.h>
+#include <net/if.h>
+#include <net/if_tun.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <arpa/inet.h>
+
+#include "ax25.h"
+
+#define SOFTWARE_NAME "aprsisd"
+#define SOFTWARE_VERSION "0.1"
+
+#define ADDRESS "85.90.180.26"
+#define PORT 14580
+
+/*
+ * TODO:
+ *
+ * - don't hardcode the server to use
+ * - really check the callsign is valid
+ * - extract paths
+ */
+
+/*
+ * Much of the APRS-IS protocol has been based on the details found at:
+ * http://www.aprs-is.net/Connecting.aspx
+ */
+
+#define TNC2_MAXLINE 512
+
+int isd, tap;
+
+int aprsis_pass(char *);
+void ax25_input(char *, int);
+void ax25_output(char *, int);
+char *tnc2_hdr_to_ax25(struct sockaddr_ax25 *, struct sockaddr_ax25 *, char *);
+void tnc2_input(char *);
+void tnc2_output(char *);
+void aprsis_remote_open(char *, int, char *, int, int, char *);
+void aprsis_local_open(char *);
+void aprsis_loop(void);
+int main(int, char **);
+
+static char *
+read_mycallsign(void)
+{
+	FILE	*mcp;
+	char	*call, *nl;
+	size_t	 callsize = 0;
+	ssize_t	 calllen;
+
+	call = NULL;
+
+	if ((mcp = fopen("/etc/mycallsign", "r")) == NULL)
+		err(1, "fopen"); //fatal("could not open /etc/mycallsign");
+	if ((calllen = getline(&call, &callsize, mcp)) != -1) {
+		if ((nl = strchr(call, '\n')) != NULL)
+			nl[0] = '\0';
+		return call;
+	}
+	err(1, "getline"); //fatal("could not read callsign from /etc/mycallsign");
+}
+
+int
+aprsis_pass(char *call)
+{
+	char *cp, *ep;
+	int16_t hash;
+	cp = call;
+	if ((ep = strchr(call, '-')) == NULL)
+		ep = cp + strlen(call);
+	hash = 0x73e2;
+	while (cp < ep) {
+		/* TODO toupper */
+		hash ^= (*(cp++) << 8);
+		if (cp < ep)
+			hash ^= (*(cp++));
+	}
+	return hash;
+}
+
+/*
+ * TODO: things get really messed up if the packet buf isn't null terminated!!!!
+ */
+void
+ax25_input(char *pkt, int len)
+{
+	char dst[10], src[10], tl[TNC2_MAXLINE];
+	int dn;
+	strlcpy(dst, ax25_ntoa((struct ax25_address *)&pkt[0]), 10);
+	strlcpy(src, ax25_ntoa((struct ax25_address *)&pkt[7]), 10);
+	snprintf(tl, TNC2_MAXLINE, "%s>%s", src, dst);
+	for (dn = 0; dn < AX25_MAXDIGIS; ++dn) {
+		if (pkt[(7 * (dn + 1)) + 6] & AX25ADDR_LASTCALL)
+			break;
+		strlcat(tl, ",", TNC2_MAXLINE);
+		strlcat(tl, ax25_ntoa((struct ax25_address *)&pkt[7 * (dn + 2)]), TNC2_MAXLINE);
+	}
+	strlcat(tl, ":", TNC2_MAXLINE);
+	strlcat(tl, &pkt[7 * (dn + 2) + 2], TNC2_MAXLINE);
+	strlcat(tl, "\n", TNC2_MAXLINE);
+	tnc2_output(tl);
+}
+
+void
+ax25_output(char *pkt, int len)
+{
+	if (write(tap, pkt, len) == -1)
+		err(1, "ax25_output: write");
+}
+
+char *
+tnc2_hdr_to_ax25(struct sockaddr_ax25 *saddr, struct sockaddr_ax25 *daddr,
+    char *s)
+{
+	char as[10];
+	struct ax25_address *addr;
+	int dn, h;
+	char *bp, *ep, *pp;
+
+	if ((pp = strchr(s, ':')) == NULL)
+		return NULL;
+	bp = ep = s;
+	for (dn = -2 ; ep != pp && dn < AX25_MAXDIGIS ; dn++) {
+		for (ep = bp; ep < pp; ep++)
+			if (*ep == '>' || *ep == ',')
+				break;
+		bzero(as, 10);
+		if (ep - bp < 3 || ep - bp > 9)
+			return NULL;
+		memcpy(as, bp, ep - bp);
+		if ((h = (as[ep - bp - 1] == '*')))
+			as[ep - bp - 1] = '\0';
+		if ((addr = ax25_aton(as)) == NULL)
+			return NULL;
+		if (h)
+			saddr->sax_path[dn].ax25_call[6] |= AX25ADDR_CR;
+		switch (dn) {
+		case -2:
+			/* source address */
+			memcpy(&saddr->sax_addr, addr, sizeof(struct ax25_address));
+			break;
+		case -1:
+			/* destination address */
+			memcpy(&daddr->sax_addr, addr, sizeof(struct ax25_address));
+			daddr->sax_addr.ax25_call[6] |= AX25ADDR_CR;
+			break;
+		default:
+			/* digi path */
+			memcpy(&saddr->sax_path[dn], addr, sizeof(struct ax25_address));
+			break;
+		}
+		bp = ep + 1;
+	}
+	if (dn == 0) {
+		saddr->sax_addr.ax25_call[6] |= AX25ADDR_LASTCALL;
+	} else {
+		saddr->sax_path[dn - 1].ax25_call[6] |= AX25ADDR_LASTCALL;
+	}
+	saddr->sax_pathlen = dn;
+	return pp + 1;
+}
+
+void
+tnc2_input(char *s)
+{
+	char pkt[1024], *payload;
+	struct sockaddr_ax25 saddr, daddr;
+	int dn, len;
+	if ((payload = tnc2_hdr_to_ax25(&saddr, &daddr, s)) == NULL)
+		return;
+	memcpy(pkt, &daddr.sax_addr, sizeof(struct ax25_address));
+	memcpy(&pkt[7], &saddr.sax_addr, sizeof(struct ax25_address));
+	for (dn = 0; dn < saddr.sax_pathlen; dn++)
+		memcpy(&pkt[14 + (7 * dn)], &saddr.sax_path[dn], sizeof(struct ax25_address));
+	pkt[14 + (7 * dn)] = 0x03;
+	pkt[15 + (7 * dn)] = 0xf0;
+	len = 16 + (7 * dn) + strlcpy(&pkt[16 + (7 * dn)], payload, 1024 - 16);
+	ax25_output(pkt, len);
+}
+
+void
+tnc2_output(char *s)
+{
+	int len = strlen(s);
+	printf("snd: %s", s);
+	if (write(isd, s, len) == -1)
+		err(1, "tnc2_output: write");
+}
+
+void
+aprsis_remote_open(char *server, int port, char *call, int ssid, int pass,
+    char *filter)
+{
+	struct sockaddr_in addr;
+	int nodelay;
+	char login[512];
+
+	if ((isd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
+		err(1, "socket");
+	}
+
+	addr.sin_port = htons(PORT);
+	addr.sin_family = AF_INET;
+
+	inet_pton(AF_INET, ADDRESS, &addr.sin_addr);
+
+	if (connect(isd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) == -1) {
+		err(1, "connect");
+	}
+
+	nodelay = 1;
+	setsockopt(isd, IPPROTO_TCP, TCP_NODELAY, &nodelay, sizeof(nodelay));
+
+	if (pass == 1234567890)
+		pass = aprsis_pass(call);
+	snprintf(login, 512, "user %s-%d pass %d vers aprsisd 0.0-dev filter %s\r\n",
+	    call, ssid, pass, filter);
+	if (write(isd, login, strlen(login)) == -1)
+		err(1, "write");
+}
+
+void aprsis_local_open(char *interface)
+{
+	struct tuninfo ti;
+	tap = open(interface, O_RDWR);
+	ioctl(tap, TUNGIFINFO, &ti);
+	ti.flags = IFF_UP | IFF_POINTOPOINT;
+	ioctl(tap, TUNSIFINFO, &ti);
+}
+
+/*
+ * Once a newline is found in the buffer, swap the CRLF (or just LF)
+ * for NUL to terminate the string and pass it to tnc2_input. Any
+ * remaining data in the buffer gets shuffled to the front and the
+ * new position in the buffer is returned.
+ */
+int
+aprsis_local_shuffle(char *buf, char* ep, int pos)
+{
+	int ei = ep - buf;
+	if (buf[ei - 1] == '\r')
+		buf[ei - 1] = '\0';
+	buf[ei++] = '\0'; /* move index to start of new packet */
+	printf("rcv: %s\n", buf);
+	if (ei > 10 && buf[0] != '#')
+		/* a reasonable minimum length and not in-band signalling */
+		tnc2_input(buf);
+	memmove(buf, &buf[ei], pos - ei);
+	pos -= ei;
+	return pos;
+}
+
+void
+aprsis_loop(void)
+{
+	struct kevent chlist[2];
+	struct kevent evlist[2];
+	int evi, kq, l_nr, nev, r_pos, r_nr;
+	char r_buf[TNC2_MAXLINE], l_buf[1500], *r_ep;
+
+	r_pos = 0;
+	bzero(r_buf, TNC2_MAXLINE);
+	bzero(l_buf, 1500);
+
+	if ((kq = kqueue()) == -1)
+		err(1, "kqueue");
+
+	EV_SET(&chlist[0], isd, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, 0);
+	EV_SET(&chlist[1], tap, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, 0);
+
+	while ((nev = kevent(kq, chlist, 2, evlist, 2, NULL)) > 0) {
+		for (evi = 0; evi < nev; evi++) {
+			if (evlist[evi].ident == tap) {
+				if ((l_nr = read(tap, l_buf, 1500)) == -1 || l_nr == 0)
+					err(1, "read tap");
+				/* TODO: validate? */
+				ax25_input(l_buf, l_nr);
+			} else if (evlist[evi].ident == isd) {
+				if (((r_nr = read(isd, &r_buf[r_pos], TNC2_MAXLINE - r_pos)) == -1) || r_nr == 0)
+					err(1, "read tcp");
+				r_pos += r_nr;
+				if ((r_ep = strchr(r_buf, '\n')) != NULL)
+					r_pos = aprsis_local_shuffle(r_buf, r_ep, r_pos);
+			}
+		}
+	}
+}
+
+int
+main(int argc, char **argv)
+{
+	char *call, *filter;
+	int isd, pass;
+
+	call = read_mycallsign();
+	pass = 1234567890;
+	filter = "m/500";
+
+	aprsis_remote_open(ADDRESS, PORT, call, 6, pass, filter);
+	aprsis_local_open("/dev/axtap0");
+
+	if (unveil(NULL, NULL) == -1)
+		err(1, "unveil");
+	if (pledge("stdio", NULL) == -1)
+		err(1, "pledge");
+
+	aprsis_loop();
+}
Index: src/usr.sbin/aprsisd/ax25.c
===================================================================
--- /dev/null
+++ src/usr.sbin/aprsisd/ax25.c
@@ -0,0 +1,67 @@
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+
+#include <sys/types.h>
+#include <netinet/in.h>
+
+#include "ax25.h"
+
+#define AX25_SSIDMASK 0b00011110
+
+char *
+ax25_ntoa(struct ax25_address *axp)
+{
+	static char buf[10];
+	int i, ssid;
+	ssid = (axp->ax25_call[6] & AX25_SSIDMASK) >> 1;
+	bzero(buf, 10);
+	for (i = 0; i < 6; i++) {
+		if (axp->ax25_call[i] == 0x40)
+			break;
+		buf[i] = axp->ax25_call[i] >> 1;
+	}
+	if (ssid == 0) {
+		buf[i] = '\0';
+	} else {
+		sprintf(&buf[i], "-%d", ssid);
+	}
+	return buf;
+}
+
+struct ax25_address *
+ax25_aton(char *s)
+{
+	static struct ax25_address ax;
+	char ssid[3];
+	int i;
+	memcpy(&ax, "\x40\x40\x40\x40\x40\x40\x00", sizeof(struct ax25_address));
+	for (i = 0; ; i++) {
+		if (s[i] == '\0') {
+			ax.ax25_call[6] = 0;
+			break;
+		}
+		if (s[i] == '-') {
+			if (isdigit(s[++i])) {
+				bzero(ssid, 3);
+				ssid[0] = s[i];
+				if (isdigit(s[++i]))
+					ssid[1] = s[i];
+				ax.ax25_call[6] = atoi(ssid) << 1;
+				if ((ax.ax25_call[6] & ~AX25_SSIDMASK) != 0) {
+					/* non AX.25 SSID */
+					return NULL;
+				}
+				break;
+			} else {
+				/* callsign is malformed */
+				return NULL;
+			}
+		}
+		ax.ax25_call[i] = s[i] << 1;
+	}
+	ax.ax25_call[6] |= AX25ADDR_RESERVED;
+	return &ax;
+}
Index: src/usr.sbin/aprsisd/ax25.h
===================================================================
--- /dev/null
+++ src/usr.sbin/aprsisd/ax25.h
@@ -0,0 +1,21 @@
+
+#define AX25ADDR_LASTCALL 0x01
+#define AX25ADDR_RESERVED (0x20 | 0x40)
+#define AX25ADDR_CR       0x80
+
+#define AX25_MAXDIGIS 8
+
+struct ax25_address {
+	unsigned char		ax25_call[7];
+};
+
+struct sockaddr_ax25 {
+	u_int8_t		sax_len;
+	sa_family_t		sax_family;
+	struct ax25_address	sax_addr;
+	int8_t			sax_pathlen;
+	struct ax25_address	sax_path[AX25_MAXDIGIS];
+};
+
+char *ax25_ntoa(struct ax25_address *);
+struct ax25_address *ax25_aton(char *);
