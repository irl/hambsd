Summary: kiss(4): ethernet over kiss
Description:
 Introduces a new tty line discipline and network interface driver to
 support the use of Ethernet with a KISS TNC.
---
Index: src/distrib/sets/lists/comp/mi
===================================================================
--- src.orig/distrib/sets/lists/comp/mi
+++ src/distrib/sets/lists/comp/mi
@@ -942,6 +942,7 @@
 ./usr/include/net/if_etherip.h
 ./usr/include/net/if_gif.h
 ./usr/include/net/if_gre.h
+./usr/include/net/if_kiss.h
 ./usr/include/net/if_llc.h
 ./usr/include/net/if_media.h
 ./usr/include/net/if_pflog.h
Index: src/sys/conf/GENERIC
===================================================================
--- src.orig/sys/conf/GENERIC
+++ src/sys/conf/GENERIC
@@ -82,6 +82,7 @@ pseudo-device	msts	1	# MSTS line discipl
 pseudo-device	endrun	1	# EndRun line discipline
 pseudo-device	vnd	4	# vnode disk devices
 pseudo-device	ksyms	1	# kernel symbols device
+pseudo-device	kiss	1	# KISS TNC line discipline
 
 # clonable devices
 pseudo-device	bpfilter	# packet filter
@@ -108,6 +109,7 @@ pseudo-device	vether		# Virtual ethernet
 pseudo-device	vxlan		# Virtual extensible LAN
 pseudo-device	vlan		# IEEE 802.1Q VLAN
 pseudo-device	switch		# Switch
+pseudo-device	ekiss		# Ethernet-over-KISS
 
 pseudo-device	bio	1	# ioctl multiplexing device
 
Index: src/sys/conf/files
===================================================================
--- src.orig/sys/conf/files
+++ src/sys/conf/files
@@ -540,6 +540,7 @@ pseudo-device pty: tty
 pseudo-device nmea: tty
 pseudo-device msts: tty
 pseudo-device endrun: tty
+pseudo-device kiss: tty
 
 pseudo-device loop: ifnet
 pseudo-device pair: ifnet, ether
@@ -566,6 +567,7 @@ pseudo-device vether: ifnet, ether
 pseudo-device pppx: ifnet
 pseudo-device vxlan: ifnet, ether, ifmedia
 pseudo-device switch: ifnet, ether
+pseudo-device ekiss: ifnet
 
 pseudo-device ksyms
 file	dev/ksyms.c			ksyms needs-flag
@@ -788,6 +790,8 @@ file net/if_ethersubr.c			ether			needs-
 file net/if_etherip.c			etherip			needs-flag
 file net/if_spppsubr.c			sppp
 file net/if_loop.c			loop
+file net/if_ekiss.c			ekiss
+file net/kiss_tty.c			kiss			needs-flag
 file net/if_media.c			ifmedia
 file net/if_ppp.c			ppp			needs-count
 file net/ppp_tty.c			ppp
Index: src/sys/kern/tty_conf.c
===================================================================
--- src.orig/sys/kern/tty_conf.c
+++ src/sys/kern/tty_conf.c
@@ -46,6 +46,7 @@
 #include "nmea.h"
 #include "msts.h"
 #include "endrun.h"
+#include "kiss.h"
 
 #define	ttynodisc ((int (*)(dev_t, struct tty *, struct proc *))enodev)
 #define	ttyerrclose ((int (*)(struct tty *, int flags, struct proc *))enodev)
@@ -107,6 +108,14 @@ struct	linesw linesw[] =
 #else
 	{ ttynodisc, ttyerrclose, ttyerrio, ttyerrio, nullioctl,
 	  ttyerrinput, ttyerrstart, nullmodem },
+#endif
+
+#if NKISS > 0
+	{ kissopen, kissclose, ttread, ttwrite, nullioctl,
+	  kissinput, ttstart, ttymodem },		/* 10- KISSDISC */
+#else
+	{ ttynodisc, ttyerrclose, ttyerrio, ttyerrio, nullioctl,
+	  ttyerrinput, ttyerrstart, nullmodem },
 #endif
 };
 
Index: src/sys/net/if_kiss.h
===================================================================
--- /dev/null
+++ src/sys/net/if_kiss.h
@@ -0,0 +1,22 @@
+
+/* Structures and declarations for KISS. */
+
+#ifndef _NET_IF_KISS_H_
+#define _NET_IF_KISS_H_
+
+struct ekiss_softc {
+	struct arpcom		 sc_ac;
+#define sc_if			 sc_ac.ac_if
+	unsigned int		 sc_dead;
+	unsigned int		 sc_promisc;
+	struct ifmedia		 sc_media;
+	void			*sc_devp; /* tty */
+	pid_t			sc_xfer; /* used in transferring unit */
+	LIST_ENTRY(ekiss_softc)	sc_list; /* all kiss interfaces */
+};
+
+struct ekiss_softc	*kissalloc(pid_t pid);
+void			 kissoutput(struct ekiss_softc *sc, struct mbuf *m);
+void			 kissregister(struct ekiss_softc *sc);
+
+#endif /* _NET_IF_KISS_H_ */
Index: src/sys/net/kiss_tty.c
===================================================================
--- /dev/null
+++ src/sys/net/kiss_tty.c
@@ -0,0 +1,332 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2006, 2007, 2008 Marc Balmer <mbalmer@openbsd.org>
+ * Copyright (c) 2019 Iain R. Learmonth <irl@fsfe.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ *  TODO:
+ *
+ *  - Set the interface as running in kissopen (and not in kissclose)
+ *  - Count the number of input errors occuring
+ */
+
+/* A tty line discipline to communicate with a KISS terminal node controller. */
+
+#include "bpfilter.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/malloc.h>
+#include <sys/tty.h>
+#include <sys/conf.h>
+#include <sys/proc.h>
+#include <sys/smr.h>
+
+#include <net/bpf.h>
+
+#include <net/if.h>
+#include <net/if_dl.h>
+#include <net/if_types.h>
+
+#include <net/if_media.h>
+
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include <net/if_kiss.h>
+
+#ifdef KISS_DEBUG
+#define DPRINTFN(n, x)	do { if (kissdebug > (n)) printf x; } while (0)
+int kissdebug = 0;
+#else
+#define DPRINTFN(n, x)
+#endif
+#define DPRINTF(x)	DPRINTFN(0, x)
+
+#define KISSMAX		1512 /* chosen arbitrarily; TODO: do better */
+
+/* special characters */
+#define KISSFEND	0xC0 /* frame end */
+#define KISSFESC	0xDB /* frame escape */
+#define KISSTFEND	0xDC /* transposed frame end */
+#define KISSTFESC	0xDD /* transposed frame escape */
+
+/* commands */
+#define KISSCMD_DATA		0x00
+#define KISSCMD_TXDELAY		0x01 /* in 10 ms units */
+#define KISSCMD_PERSIST		0x02 /* used for CSMA */
+#define KISSCMD_SLOTTIME	0x03 /* in 10 ms units */
+#define KISSCMD_TXTAIL		0x04 /* in 10 ms units */
+#define KISSCMD_FULLDUPLEX	0x05 /* 0=half, anything else=full */
+#define KISSCMD_SETHARDWARE	0x06 /* this is not implemented anywhere here */
+#define KISSCMD_RETURN		0xFF /* on all ports */
+
+LIST_HEAD(, ekiss_softc) kiss_softc_list;
+
+int kiss_count, kiss_nxid;
+
+/* flags for (struct kiss)->sc_flags */
+#define KISSFLAG_NEW	1
+#define KISSFLAG_DATA	2
+#define KISSFLAG_ESCAPE	4
+
+/* software control block for kiss line discipline */
+struct kiss {
+	char			 ks_cbuf[KISSMAX];	/* reveive buffer */
+	int			 ks_flags;		/* async line flags; KISSFLAG_* */
+	int			 ks_id;			/* instance id */
+	int			 ks_port;		/* rcv from port */
+	int			 ks_pos;		/* rcv buf position */
+	struct ekiss_softc	*ks_netp;		/* interface sc */
+#define ks_devp			 ks_netp->sc_devp
+};
+
+void kissattach(int dummy) {
+	/* noop */
+}
+
+/* take over a tty and match with a kiss net interface. */
+int
+kissopen(dev_t dev, struct tty *tp, struct proc *p)
+{
+	struct ekiss_softc *sc;
+	struct kiss *ks;
+	int error;
+
+	if (tp->t_line == KISSDISC)
+		return (ENODEV);
+	if ((error = suser(p)) != 0)
+		return (error);
+	if ((sc = kissalloc(p->p_p->ps_pid)) == NULL) {
+		/* most likely there are no kissN interfaces */
+		return ENXIO;
+	}
+	ks = malloc(sizeof(struct kiss), M_DEVBUF, M_WAITOK | M_ZERO);
+
+	ks->ks_id = kiss_nxid++;
+	kiss_count++;
+	ks->ks_netp = sc;
+	sc->sc_devp = (void*)tp;
+	tp->t_sc = (caddr_t)ks;
+
+	error = linesw[TTYDISC].l_open(dev, tp, p);
+	// TODO: do we really need to call this?
+	if (error) {
+		free(sc, M_DEVBUF, sizeof(*sc));
+		tp->t_sc = NULL;
+	}
+	return (error);
+}
+
+/* clean up and set the tty back to termios. */
+int
+kissclose(struct tty *tp, int flags, struct proc *p)
+{
+	struct kiss *ks = (struct kiss *)tp->t_sc;
+	ks->ks_devp = NULL;
+	free(ks, M_DEVBUF, sizeof(*ks));
+	tp->t_line = TTYDISC;	/* switch back to termios */
+	tp->t_sc = NULL;
+	kiss_count--;
+	if (kiss_count == 0)
+		kiss_nxid = 0;
+	return (linesw[TTYDISC].l_close(tp, flags, p));
+	// TODO: do we really need to call this?
+}
+
+/* tty input interrupt handler. collects kiss frames. */
+int
+kissinput(int c, struct tty *tp)
+{
+	struct kiss *ks = (struct kiss *)tp->t_sc;
+
+	if (c == KISSFEND) {
+		if (ks->ks_flags & KISSFLAG_DATA && ks->ks_pos > 14) {
+			struct mbuf *m = m_devget(ks->ks_cbuf, ks->ks_pos, 0);
+			if_vinput(&ks->ks_netp->sc_if, m);
+		}
+		ks->ks_flags = KISSFLAG_NEW;
+		return 0;
+	}
+
+	if (ks->ks_flags & KISSFLAG_NEW) {
+		/* this is the first byte in a new frame. */
+		int port = (c & 0xF0) >> 4;
+		int command = c & 0x0F;
+
+		ks->ks_flags = 0;
+
+		switch (command) {
+		case KISSCMD_DATA:
+			ks->ks_port = port;
+			ks->ks_pos = 0;
+			ks->ks_flags |= KISSFLAG_DATA;
+			break;
+		default:
+			printf("kiss: unrecognised command received on port %d\n", port);
+			break;
+		}
+		return 0;
+	}
+
+	if (c == KISSFESC) {
+		ks->ks_flags |= KISSFLAG_ESCAPE;
+		return 0;
+	}
+
+	if (ks->ks_flags & KISSFLAG_ESCAPE) {
+		int escaped = 0;
+		switch (c) {
+		case KISSTFESC:
+			escaped = KISSFESC;
+			break;
+		case KISSTFEND:
+			escaped = KISSFEND;
+			break;
+		}
+		if (escaped) {
+			c = escaped;
+		} else {
+			/* abort this packet. */
+			ks->ks_flags &= ~KISSFLAG_DATA;
+		}
+		ks->ks_flags &= ~KISSFLAG_ESCAPE;
+	}
+
+	if (ks->ks_flags & KISSFLAG_DATA) {
+		if (ks->ks_pos < (KISSMAX - 1)) {
+			ks->ks_cbuf[ks->ks_pos++] = c;
+		} else {
+			/* abort the packet. */
+			ks->ks_flags &= ~KISSFLAG_DATA;
+		}
+	}
+	return 0;
+}
+
+/* output a kiss frame with packet data from an mbuf. */
+void
+kissoutput(struct ekiss_softc *sc, struct mbuf *m) {
+	int s;
+	register u_char *cp;
+	struct tty *tp = (struct tty *)sc->sc_devp;
+#if NBPFILTER > 0
+	struct ifnet *ifp = &sc->sc_if;
+
+	if (ifp->if_bpf) {
+		if (bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT)) {
+			m_freem(m);
+			return;
+		}
+	}
+#endif
+
+	smr_read_enter(); // TODO: what is this protecting?
+	s = spltty();
+	putc(KISSFEND, &tp->t_outq);
+	putc(KISSCMD_DATA, &tp->t_outq); /* implicitly port 0 */
+
+	while (m) {
+		register u_char *ep;
+
+		cp = mtod(m, u_char *); ep = cp + m->m_len;
+		while (cp < ep) {
+			/*
+			 * Find out how many bytes in the string we can
+			 * handle without doing something special.
+			 */
+			register u_char *bp = cp;
+
+			while (cp < ep) {
+				switch (*cp++) {
+				case KISSFESC:
+				case KISSFEND:
+					--cp;
+					goto out;
+				}
+			}
+			out:
+			if (cp > bp) {
+				/*
+				 * Put n characters at once
+				 * into the tty output queue.
+				 */
+				if (b_to_q((char *)bp, cp - bp,
+				    &tp->t_outq))
+					break;
+				sc->sc_if.if_obytes += cp - bp;
+			}
+			/*
+			 * If there are characters left in the mbuf,
+			 * the first one must be special..
+			 * Put it out in a different form.
+			 */
+			if (cp < ep) {
+				if (putc(KISSFESC, &tp->t_outq))
+					break;
+				if (putc(*cp++ == KISSFESC ?
+				   KISSTFESC : KISSTFEND,
+				   &tp->t_outq)) {
+					(void) unputc(&tp->t_outq);
+					break;
+				}
+				sc->sc_if.if_obytes += 2;
+			}
+		}
+		m = m_free(m);
+	}
+
+	putc(KISSFEND, &tp->t_outq);
+	splx(s);
+	ttstart(tp);
+	smr_read_leave();
+}
+
+/* allocate the first available network interface. */
+struct ekiss_softc *
+kissalloc(pid_t pid)
+{
+	struct ekiss_softc *sc;
+
+	NET_LOCK();
+	LIST_FOREACH(sc, &kiss_softc_list, sc_list) {
+		if (sc->sc_xfer == pid) {
+			sc->sc_xfer = 0;
+			NET_UNLOCK();
+			return sc;
+		}
+	}
+	LIST_FOREACH(sc, &kiss_softc_list, sc_list) {
+		if (sc->sc_devp == NULL)
+			break;
+	}
+	NET_UNLOCK();
+	if (sc == NULL)
+		return NULL;
+
+	return sc;
+}
+
+/* register a kiss interface with the line discipline. */
+void
+kissregister(struct ekiss_softc *sc)
+{
+	NET_LOCK();
+	LIST_INSERT_HEAD(&kiss_softc_list, sc, sc_list);
+	NET_UNLOCK();
+}
+
Index: src/sys/sys/tty.h
===================================================================
--- src.orig/sys/sys/tty.h
+++ src/sys/sys/tty.h
@@ -333,4 +333,8 @@ int	endrunopen(dev_t, struct tty *, stru
 int	endrunclose(struct tty *, int, struct proc *);
 int	endruninput(int, struct tty *);
 
+int	kissopen(dev_t, struct tty *, struct proc *);
+int	kissclose(struct tty *, int, struct proc *);
+int	kissinput(int, struct tty *);
+
 #endif /* _KERNEL */
Index: src/sys/sys/ttycom.h
===================================================================
--- src.orig/sys/sys/ttycom.h
+++ src/sys/sys/ttycom.h
@@ -147,5 +147,6 @@ struct tstamps {
 #define	NMEADISC	7		/* NMEA0183 discipline */
 #define	MSTSDISC	8		/* Meinberg time string discipline */
 #define	ENDRUNDISC	9		/* EndRun time format discipline */
+#define	KISSDISC	10		/* KISS TNC discipline */
 
 #endif /* !_SYS_TTYCOM_H_ */
Index: src/sys/net/if_ekiss.c
===================================================================
--- /dev/null
+++ src/sys/net/if_ekiss.c
@@ -0,0 +1,286 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2019 Iain R. Learmonth <irl@fsfe.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ *  TODO:
+ *
+ * - Rename to ekiss, expecting a future axkiss interface.
+ * - Make sure that both ekiss and axkiss can share kiss(4) line disc.
+ * - This might mean not using the same software control block for both.
+ */
+
+/* A network interface using Ethernet over a KISS TNC. */
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/systm.h>
+#include <sys/syslog.h>
+#include <sys/rwlock.h>
+#include <sys/percpu.h>
+#include <sys/smr.h>
+#include <sys/task.h>
+
+#include <sys/tty.h>
+#include <sys/fcntl.h>
+
+#include <net/if.h>
+#include <net/if_dl.h>
+#include <net/if_types.h>
+
+#include <net/if_media.h>
+
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include <net/if_kiss.h>
+
+static int	ekiss_clone_create(struct if_clone *, int);
+static int	ekiss_clone_destroy(struct ifnet *);
+
+static int	ekiss_ioctl(struct ifnet *, u_long, caddr_t);
+static void	ekiss_start(struct ifqueue *);
+static int	ekiss_enqueue(struct ifnet *, struct mbuf *);
+
+static int	ekiss_media_change(struct ifnet *);
+static void	ekiss_media_status(struct ifnet *, struct ifmediareq *);
+
+static int	ekiss_up(struct ekiss_softc *);
+static int	ekiss_down(struct ekiss_softc *);
+static int	ekiss_iff(struct ekiss_softc *);
+
+static struct if_clone ekiss_cloner =
+    IF_CLONE_INITIALIZER("ekiss", ekiss_clone_create, ekiss_clone_destroy);
+
+void
+ekissattach(int count)
+{
+	if_clone_attach(&ekiss_cloner);
+}
+
+static int
+ekiss_clone_create(struct if_clone *ifc, int unit)
+{
+	struct ekiss_softc *sc;
+	struct ifnet *ifp;
+
+	sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK|M_ZERO|M_CANFAIL);
+	if (sc == NULL)
+		return (ENOMEM);
+
+	ifp = &sc->sc_if;
+
+	snprintf(ifp->if_xname, sizeof(ifp->if_xname), "%s%d",
+	    ifc->ifc_name, unit);
+
+	ifmedia_init(&sc->sc_media, 0, ekiss_media_change, ekiss_media_status);
+	ifmedia_add(&sc->sc_media, IFM_ETHER | IFM_AUTO, 0, NULL);
+	ifmedia_set(&sc->sc_media, IFM_ETHER | IFM_AUTO);
+
+	ifp->if_softc = sc;
+	ifp->if_hardmtu = ETHER_MAX_HARDMTU_LEN;
+	ifp->if_ioctl = ekiss_ioctl;
+	ifp->if_qstart = ekiss_start;
+	ifp->if_enqueue = ekiss_enqueue;
+	ifp->if_flags = IFF_BROADCAST | IFF_MULTICAST | IFF_SIMPLEX;
+	ifp->if_xflags = IFXF_CLONED | IFXF_MPSAFE;
+	ifp->if_link_state = LINK_STATE_UP;
+	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
+	ether_fakeaddr(ifp);
+
+	if_counters_alloc(ifp);
+	if_attach(ifp);
+	ether_ifattach(ifp);
+
+	ifp->if_llprio = IFQ_MAXPRIO;
+
+	kissregister(sc);
+
+	return (0);
+}
+
+static int
+ekiss_clone_destroy(struct ifnet *ifp)
+{
+	struct ekiss_softc *sc = ifp->if_softc;
+
+	NET_LOCK();
+	sc->sc_dead = 1;
+
+	if (ISSET(ifp->if_flags, IFF_RUNNING))
+		ekiss_down(sc);
+	NET_UNLOCK();
+
+	ether_ifdetach(ifp);
+	if_detach(ifp);
+
+	free(sc, M_DEVBUF, sizeof(*sc));
+
+	return (0);
+}
+
+static int
+ekiss_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
+{
+	struct ekiss_softc *sc = ifp->if_softc;
+	struct ifreq *ifr = (struct ifreq *)data;
+	int error = 0;
+
+	if (sc->sc_dead)
+		return (ENXIO);
+
+	switch (cmd) {
+	case SIOCSIFADDR:
+		break;
+
+	case SIOCSIFFLAGS:
+		if (ISSET(ifp->if_flags, IFF_UP)) {
+			if (!ISSET(ifp->if_flags, IFF_RUNNING))
+				error = ekiss_up(sc);
+			else
+				error = ENETRESET;
+		} else {
+			if (ISSET(ifp->if_flags, IFF_RUNNING))
+				error = ekiss_down(sc);
+		}
+		break;
+
+	case SIOCSIFLLADDR:
+		error = EOPNOTSUPP;
+		//error = kiss_set_lladdr(sc, ifr);
+		break;
+
+	case SIOCSIFMTU:
+		error = EOPNOTSUPP;
+		//error = kiss_set_mtu(sc, ifr->ifr_mtu);
+		break;
+
+	case SIOCSIFMEDIA:
+		error = EOPNOTSUPP;
+		break;
+	case SIOCGIFMEDIA:
+		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
+		break;
+
+	default:
+		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
+		break;
+	}
+
+	if (error == ENETRESET)
+		error = ekiss_iff(sc);
+
+	return (error);
+}
+
+static void
+ekiss_start(struct ifqueue *ifq)
+{
+	struct ifnet *ifp = ifq->ifq_if;
+	struct ekiss_softc *sc = ifp->if_softc;
+
+	smr_read_enter();
+	struct mbuf *m;
+	while ((m = ifq_dequeue(ifq)) != NULL)
+		kissoutput(sc, m);
+	smr_read_leave();
+}
+
+static int
+ekiss_enqueue(struct ifnet *ifp, struct mbuf *m)
+{
+	struct ekiss_softc *sc;
+	int error;
+
+	error = 0;
+
+	if (!ifq_is_priq(&ifp->if_snd))
+		return (if_enqueue_ifq(ifp, m));
+
+	/* if there's the wrong ldisc then abort */
+
+	sc = ifp->if_softc;
+
+	if (sc->sc_devp == NULL)
+		return (EINVAL);
+
+	counters_pkt(ifp->if_counters,
+	    ifc_opackets, ifc_obytes, m->m_pkthdr.len);
+
+	kissoutput(sc, m);
+
+	return (error);
+}
+
+static int
+ekiss_media_change(struct ifnet *ifp)
+{
+	return (EOPNOTSUPP);
+}
+
+static void
+ekiss_media_status(struct ifnet *ifp, struct ifmediareq *imr)
+{
+	//struct ekiss_softc *sc = ifp->if_softc;
+
+	imr->ifm_status = IFM_AVALID;
+	imr->ifm_active = IFM_ETHER | IFM_AUTO | IFM_ACTIVE;
+}
+
+static int
+ekiss_up(struct ekiss_softc *sc)
+{
+	struct ifnet *ifp = &sc->sc_if;
+
+	NET_ASSERT_LOCKED();
+	KASSERT(!ISSET(ifp->if_flags, IFF_RUNNING));
+
+	SET(ifp->if_flags, IFF_RUNNING);
+
+	return (ENETRESET);
+}
+
+static int
+ekiss_down(struct ekiss_softc *sc)
+{
+	struct ifnet *ifp = &sc->sc_if;
+
+	NET_ASSERT_LOCKED();
+	CLR(ifp->if_flags, IFF_RUNNING);
+
+	return (ENETRESET);
+}
+
+static int
+ekiss_iff(struct ekiss_softc *sc)
+{
+	struct ifnet *ifp = &sc->sc_if;
+	unsigned int promisc = ISSET(ifp->if_flags, IFF_PROMISC);
+
+	NET_ASSERT_LOCKED();
+
+	if (promisc != sc->sc_promisc) {
+		sc->sc_promisc = promisc;
+	}
+
+	return (0);
+}
