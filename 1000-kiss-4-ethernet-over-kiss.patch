Summary: kiss(4): ethernet over kiss
Description:
 Introduces a new tty line discipline and network interface driver to
 support the use of Ethernet with a KISS TNC.
---
Index: src/distrib/sets/lists/comp/mi
===================================================================
--- src.orig/distrib/sets/lists/comp/mi
+++ src/distrib/sets/lists/comp/mi
@@ -944,6 +944,7 @@
 ./usr/include/net/if_etherip.h
 ./usr/include/net/if_gif.h
 ./usr/include/net/if_gre.h
+./usr/include/net/if_kiss.h
 ./usr/include/net/if_llc.h
 ./usr/include/net/if_media.h
 ./usr/include/net/if_mobileip.h
Index: src/sbin/ldattach/ldattach.8
===================================================================
--- src.orig/sbin/ldattach/ldattach.8
+++ src/sbin/ldattach/ldattach.8
@@ -14,7 +14,7 @@
 .\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 .\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 .\"
-.Dd $Mdocdate: October 2 2014 $
+.Dd $Mdocdate: September 01 2019 $
 .Dt LDATTACH 8
 .Os
 .Sh NAME
@@ -117,6 +117,10 @@ line discipline.
 Attach the
 .Xr nmea 4
 line discipline.
+.It kiss
+Attach the
+.Xr kiss 4
+line discipline.
 .El
 .It Ar device
 Specifies the name of the serial line.
@@ -163,6 +167,7 @@ tty01	"/sbin/ldattach nmea"	unknown	on s
 .Xr endrun 4 ,
 .Xr msts 4 ,
 .Xr nmea 4 ,
+.Xr kiss 4 ,
 .Xr pty 4 ,
 .Xr tty 4 ,
 .Xr ttys 5 ,
Index: src/sbin/ldattach/ldattach.c
===================================================================
--- src.orig/sbin/ldattach/ldattach.c
+++ src/sbin/ldattach/ldattach.c
@@ -205,6 +205,8 @@ main(int argc, char *argv[])
 		ldisc = MSTSDISC;
 	} else if (!strcmp(disc, "endrun")) {
 		ldisc = ENDRUNDISC;
+	} else if (!strcmp(disc, "kiss")) {
+		ldisc = KISSDISC;
 	} else {
 		syslog(LOG_ERR, "unknown line discipline %s", disc);
 		goto bail_out;
Index: src/share/man/man4/kiss.4
===================================================================
--- /dev/null
+++ src/share/man/man4/kiss.4
@@ -0,0 +1,109 @@
+.\"	$OpenBSD$
+.\"
+.\" Copyright (c) 1983, 1991, 1993
+.\"	The Regents of the University of California.  All rights reserved.
+.\" Copyright (c) 2019 Iain R. Leamonth <irl@fsfe.org>
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. Neither the name of the University nor the names of its contributors
+.\"    may be used to endorse or promote products derived from this software
+.\"    without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\"     From:	@(#)lo.4	8.1 (Berkeley) 6/5/93
+.\"
+.Dd $Mdocdate: September 01 2019 $
+.Dt KISS 4
+.Os
+.Sh NAME
+.Nm kiss
+.Nd KISS line discipline
+.Sh SYNOPSIS
+.Cd "pseudo-device kiss"
+.Sh DESCRIPTION
+The
+.Nm
+line discipline can be attached to serial lines to communicate with a TNC,
+including the following:
+.Bl -bullet
+.It
+Dire Wolf
+.El
+.Pp
+When this line discipline is first attached, it will in turn attach to the first
+available
+.Xr ekiss 4
+network interface, or any other interface that has registered with the line
+discipline.
+.Pp
+For general use, once the interface has been created and configured, the line
+discipline can be attached using
+.Xr ldattach 8 .
+For example, assuming the TNC is connected to
+.Pa /dev/cua00 :
+.Bd -literal
+$ ldattach kiss cua00
+.Ed
+.Pp
+The line discipline is also enabled by the following sequence:
+.Bd -literal -offset indent
+#include <sys/ioctl.h>
+int ldisc = KISSDISC, fd; ...
+ioctl(fd, TIOCSETD, &ldisc);
+.Ed
+.Pp
+Input and output on the serial line is then intercepted and handled by the
+kernel, and will not be available via the
+.Xr read 2
+and
+.Xr write 2
+system calls.
+.Sh MULTI-DROP KISS
+.Pp
+The line discipline is aware of multi-drop in as far as incoming data on ports
+other than 0 will be ignored and will not trigger error conditions. The
+additional commands, acknowledge or polled mode, are not implemented. All data
+will be sent on port 0.
+.Sh SEE ALSO
+.Xr tty 4 ,
+.Xr ldattach 8
+.Sh REFERENCES
+.Bl -bullet
+.It
+.Rs
+.%A Mike Chepponis, K3MC
+.%A Phil Karn, KA9Q
+.%D 1987
+.%T The KISS TNC: A simple Host-to-TNC communications protocol
+.%B ARRL 6th Computer Networking Conference
+.%C Redondo Beach, CA, United States.
+.Re
+.It
+.Rs
+.%A Karl Medcalf, WK5M
+.%D 1991
+.%T Multi-Drop KISS operation
+.%B ARRL 10th Computer Networking Conference
+.%C San Jose, CA, United States.
+.Re
+.El
+.Sh BUGS
+Currently, too many to enumerate. Look out for TODO: entries in the codebase.
Index: src/sys/conf/GENERIC
===================================================================
--- src.orig/sys/conf/GENERIC
+++ src/sys/conf/GENERIC
@@ -82,6 +82,7 @@ pseudo-device	msts	1	# MSTS line discipl
 pseudo-device	endrun	1	# EndRun line discipline
 pseudo-device	vnd	4	# vnode disk devices
 pseudo-device	ksyms	1	# kernel symbols device
+pseudo-device	kiss	1	# KISS TNC line discipline
 
 # clonable devices
 pseudo-device	bpfilter	# packet filter
Index: src/sys/conf/files
===================================================================
--- src.orig/sys/conf/files
+++ src/sys/conf/files
@@ -545,6 +545,7 @@ pseudo-device pty: tty
 pseudo-device nmea: tty
 pseudo-device msts: tty
 pseudo-device endrun: tty
+pseudo-device kiss: tty
 
 pseudo-device loop: ifnet
 pseudo-device pair: ifnet, ether
@@ -794,6 +795,8 @@ file net/if_ethersubr.c			ether			needs-
 file net/if_etherip.c			etherip			needs-flag
 file net/if_spppsubr.c			sppp
 file net/if_loop.c			loop
+file net/if_kiss.c			kiss
+file net/kiss_tty.c			kiss			needs-flag
 file net/if_media.c			ifmedia
 file net/if_ppp.c			ppp			needs-count
 file net/ppp_tty.c			ppp
Index: src/sys/kern/tty_conf.c
===================================================================
--- src.orig/sys/kern/tty_conf.c
+++ src/sys/kern/tty_conf.c
@@ -46,6 +46,7 @@
 #include "nmea.h"
 #include "msts.h"
 #include "endrun.h"
+#include "kiss.h"
 
 #define	ttynodisc ((int (*)(dev_t, struct tty *, struct proc *))enodev)
 #define	ttyerrclose ((int (*)(struct tty *, int flags, struct proc *))enodev)
@@ -107,6 +108,14 @@ struct	linesw linesw[] =
 #else
 	{ ttynodisc, ttyerrclose, ttyerrio, ttyerrio, nullioctl,
 	  ttyerrinput, ttyerrstart, nullmodem },
+#endif
+
+#if NKISS > 0
+	{ kissopen, kissclose, ttread, ttwrite, nullioctl,
+	  kissinput, ttstart, ttymodem },		/* 10- KISSDISC */
+#else
+	{ ttynodisc, ttyerrclose, ttyerrio, ttyerrio, nullioctl,
+	  ttyerrinput, ttyerrstart, nullmodem },
 #endif
 };
 
Index: src/sys/net/if_kiss.c
===================================================================
--- /dev/null
+++ src/sys/net/if_kiss.c
@@ -0,0 +1,287 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2019 Iain R. Learmonth <irl@fsfe.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ *  TODO:
+ *
+ * - Rename to ekiss, expecting a future axkiss interface.
+ * - Make sure that both ekiss and axkiss can share kiss(4) line disc.
+ * - This might mean not using the same software control block for both.
+ */
+
+/* A network interface using Ethernet over a KISS TNC. */
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/systm.h>
+#include <sys/syslog.h>
+#include <sys/rwlock.h>
+#include <sys/percpu.h>
+#include <sys/smr.h>
+#include <sys/task.h>
+
+#include <sys/tty.h>
+#include <sys/fcntl.h>
+
+#include <net/if.h>
+#include <net/if_dl.h>
+#include <net/if_types.h>
+
+#include <net/if_media.h>
+
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include <net/if_kiss.h>
+
+static int	kiss_clone_create(struct if_clone *, int);
+static int	kiss_clone_destroy(struct ifnet *);
+
+static int	kiss_ioctl(struct ifnet *, u_long, caddr_t);
+static void	kiss_start(struct ifqueue *);
+static int	kiss_enqueue(struct ifnet *, struct mbuf *);
+
+static int	kiss_media_change(struct ifnet *);
+static void	kiss_media_status(struct ifnet *, struct ifmediareq *);
+
+static int	kiss_up(struct kiss_softc *);
+static int	kiss_down(struct kiss_softc *);
+static int	kiss_iff(struct kiss_softc *);
+
+static struct if_clone kiss_cloner =
+    IF_CLONE_INITIALIZER("kiss", kiss_clone_create, kiss_clone_destroy);
+
+void
+kissattach(int count)
+{
+	if_clone_attach(&kiss_cloner);
+}
+
+static int
+kiss_clone_create(struct if_clone *ifc, int unit)
+{
+	struct kiss_softc *sc;
+	struct ifnet *ifp;
+
+	sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK|M_ZERO|M_CANFAIL);
+	if (sc == NULL)
+		return (ENOMEM);
+
+	ifp = &sc->sc_if;
+
+	snprintf(ifp->if_xname, sizeof(ifp->if_xname), "%s%d",
+	    ifc->ifc_name, unit);
+
+	ifmedia_init(&sc->sc_media, 0, kiss_media_change, kiss_media_status);
+	ifmedia_add(&sc->sc_media, IFM_ETHER | IFM_AUTO, 0, NULL);
+	ifmedia_set(&sc->sc_media, IFM_ETHER | IFM_AUTO);
+
+	ifp->if_softc = sc;
+	ifp->if_hardmtu = ETHER_MAX_HARDMTU_LEN;
+	ifp->if_ioctl = kiss_ioctl;
+	ifp->if_qstart = kiss_start;
+	ifp->if_output = ether_output;
+	ifp->if_enqueue = kiss_enqueue;
+	ifp->if_flags = IFF_BROADCAST | IFF_MULTICAST | IFF_SIMPLEX;
+	ifp->if_xflags = IFXF_CLONED | IFXF_MPSAFE;
+	ifp->if_link_state = LINK_STATE_DOWN;
+	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
+	ether_fakeaddr(ifp);
+
+	if_counters_alloc(ifp);
+	if_attach(ifp);
+	ether_ifattach(ifp);
+
+	ifp->if_llprio = IFQ_MAXPRIO;
+
+	kissregister(sc);
+
+	return (0);
+}
+
+static int
+kiss_clone_destroy(struct ifnet *ifp)
+{
+	struct kiss_softc *sc = ifp->if_softc;
+
+	NET_LOCK();
+	sc->sc_dead = 1;
+
+	if (ISSET(ifp->if_flags, IFF_RUNNING))
+		kiss_down(sc);
+	NET_UNLOCK();
+
+	ether_ifdetach(ifp);
+	if_detach(ifp);
+
+	free(sc, M_DEVBUF, sizeof(*sc));
+
+	return (0);
+}
+
+static int
+kiss_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
+{
+	struct kiss_softc *sc = ifp->if_softc;
+	struct ifreq *ifr = (struct ifreq *)data;
+	int error = 0;
+
+	if (sc->sc_dead)
+		return (ENXIO);
+
+	switch (cmd) {
+	case SIOCSIFADDR:
+		break;
+
+	case SIOCSIFFLAGS:
+		if (ISSET(ifp->if_flags, IFF_UP)) {
+			if (!ISSET(ifp->if_flags, IFF_RUNNING))
+				error = kiss_up(sc);
+			else
+				error = ENETRESET;
+		} else {
+			if (ISSET(ifp->if_flags, IFF_RUNNING))
+				error = kiss_down(sc);
+		}
+		break;
+
+	case SIOCSIFLLADDR:
+		error = EOPNOTSUPP;
+		//error = kiss_set_lladdr(sc, ifr);
+		break;
+
+	case SIOCSIFMTU:
+		error = EOPNOTSUPP;
+		//error = kiss_set_mtu(sc, ifr->ifr_mtu);
+		break;
+
+	case SIOCSIFMEDIA:
+		error = EOPNOTSUPP;
+		break;
+	case SIOCGIFMEDIA:
+		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
+		break;
+
+	default:
+		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
+		break;
+	}
+
+	if (error == ENETRESET)
+		error = kiss_iff(sc);
+
+	return (error);
+}
+
+static void
+kiss_start(struct ifqueue *ifq)
+{
+	struct ifnet *ifp = ifq->ifq_if;
+	struct kiss_softc *sc = ifp->if_softc;
+
+	smr_read_enter();
+	struct mbuf *m;
+	while ((m = ifq_dequeue(ifq)) != NULL)
+		kissoutput(sc, m);
+	smr_read_leave();
+}
+
+static int
+kiss_enqueue(struct ifnet *ifp, struct mbuf *m)
+{
+	struct kiss_softc *sc;
+	int error;
+
+	error = 0;
+
+	if (!ifq_is_priq(&ifp->if_snd))
+		return (if_enqueue_ifq(ifp, m));
+
+	/* if there's the wrong ldisc then abort */
+
+	sc = ifp->if_softc;
+
+	if (sc->sc_devp == NULL)
+		return (EINVAL);
+
+	counters_pkt(ifp->if_counters,
+	    ifc_opackets, ifc_obytes, m->m_pkthdr.len);
+
+	kissoutput(sc, m);
+
+	return (error);
+}
+
+static int
+kiss_media_change(struct ifnet *ifp)
+{
+	return (EOPNOTSUPP);
+}
+
+static void
+kiss_media_status(struct ifnet *ifp, struct ifmediareq *imr)
+{
+	//struct kiss_softc *sc = ifp->if_softc;
+
+	imr->ifm_status = IFM_AVALID;
+	imr->ifm_active = IFM_ETHER | IFM_AUTO | IFM_ACTIVE;
+}
+
+static int
+kiss_up(struct kiss_softc *sc)
+{
+	struct ifnet *ifp = &sc->sc_if;
+
+	NET_ASSERT_LOCKED();
+	KASSERT(!ISSET(ifp->if_flags, IFF_RUNNING));
+
+	SET(ifp->if_flags, IFF_RUNNING);
+
+	return (ENETRESET);
+}
+
+static int
+kiss_down(struct kiss_softc *sc)
+{
+	struct ifnet *ifp = &sc->sc_if;
+
+	NET_ASSERT_LOCKED();
+	CLR(ifp->if_flags, IFF_RUNNING);
+
+	return (ENETRESET);
+}
+
+static int
+kiss_iff(struct kiss_softc *sc)
+{
+	struct ifnet *ifp = &sc->sc_if;
+	unsigned int promisc = ISSET(ifp->if_flags, IFF_PROMISC);
+
+	NET_ASSERT_LOCKED();
+
+	if (promisc != sc->sc_promisc) {
+		sc->sc_promisc = promisc;
+	}
+
+	return (0);
+}
Index: src/sys/net/if_kiss.h
===================================================================
--- /dev/null
+++ src/sys/net/if_kiss.h
@@ -0,0 +1,60 @@
+
+/* Structures and declarations for KISS. */
+
+#ifndef _NET_IF_KISS_H_
+#define _NET_IF_KISS_H_
+
+/* TODO: Some of these may need to be public, some private, split it up? */
+
+#ifdef KISS_DEBUG
+#define DPRINTFN(n, x)	do { if (kissdebug > (n)) printf x; } while (0)
+int kissdebug = 0;
+#else
+#define DPRINTFN(n, x)
+#endif
+#define DPRINTF(x)	DPRINTFN(0, x)
+
+#define KISSMAX		1512 /* chosen arbitrarily; TODO: do better */
+
+#define KISSFEND	0xC0 /* frame end */
+#define KISSFESC	0xDB /* frame escape */
+#define KISSTFEND	0xDC /* transposed frame end */
+#define KISSTFESC	0xDD /* transposed frame escape */
+
+#define KISSCMD_DATA		0x00
+#define KISSCMD_TXDELAY		0x01 /* in 10 ms units */
+#define KISSCMD_PERSIST		0x02 /* used for CSMA */
+#define KISSCMD_SLOTTIME	0x03 /* in 10 ms units */
+#define KISSCMD_TXTAIL		0x04 /* in 10 ms units */
+#define KISSCMD_FULLDUPLEX	0x05 /* 0=half, anything else=full */
+#define KISSCMD_SETHARDWARE	0x06 /* this is not implemented anywhere here */
+#define KISSCMD_RETURN		0xFF /* on all ports */
+
+#define KISSSC_NEW	1
+#define KISSSC_DATA	2
+#define KISSSC_ESCAPE	4
+
+struct kiss_softc {
+	/* network interface */
+	struct arpcom		sc_ac;
+#define sc_if			sc_ac.ac_if
+	unsigned int		sc_dead;
+	unsigned int		sc_promisc;
+	struct ifmedia		sc_media;
+
+	/* line discipline */
+	void			*sc_devp; /* tty */
+	int			port; /* port index of current recvd data */
+	char			cbuf[KISSMAX];	/* receive buffer */
+	int			pos; /* position in rcv buffer */
+	unsigned int		sc_flags; /* see KISSSC_* */
+
+	pid_t	sc_xfer; /* used in transferring unit */
+	LIST_ENTRY(kiss_softc) sc_list; /* all kiss interfaces */
+};
+
+struct kiss_softc *kissalloc(pid_t pid);
+void kissoutput(struct kiss_softc *sc, struct mbuf *m);
+void kissregister(struct kiss_softc *sc);
+
+#endif /* _NET_IF_KISS_H_ */
Index: src/sys/net/kiss_tty.c
===================================================================
--- /dev/null
+++ src/sys/net/kiss_tty.c
@@ -0,0 +1,277 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2006, 2007, 2008 Marc Balmer <mbalmer@openbsd.org>
+ * Copyright (c) 2019 Iain R. Learmonth <irl@fsfe.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ *  TODO:
+ *
+ *  - Set the interface as running in kissopen (and not in kissclose)
+ *  - Count the number of input errors occuring
+ */
+
+/* A tty line discipline to communicate with a KISS terminal node controller. */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/malloc.h>
+#include <sys/tty.h>
+#include <sys/conf.h>
+#include <sys/proc.h>
+#include <sys/smr.h>
+
+#include <net/if.h>
+#include <net/if_dl.h>
+#include <net/if_types.h>
+
+#include <net/if_media.h>
+
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include <net/if_kiss.h>
+
+LIST_HEAD(, kiss_softc) kiss_softc_list;
+
+void kissreturn(struct tty *tp);
+void kissinputdone(struct kiss_softc *sc);
+
+/* take over a tty and match with a kiss net interface. */
+int
+kissopen(dev_t dev, struct tty *tp, struct proc *p)
+{
+	struct kiss_softc *sc;
+	int error;
+
+	if (tp->t_line == KISSDISC)
+		return (ENODEV);
+	if ((error = suser(p)) != 0)
+		return (error);
+	if ((sc = kissalloc(p->p_p->ps_pid)) == NULL) {
+		/* most likely there are no kissN interfaces */
+		return ENXIO;
+	}
+
+	tp->t_sc = (caddr_t)sc;
+	sc->sc_devp = (void*)tp;
+
+	error = linesw[TTYDISC].l_open(dev, tp, p);
+	// TODO: do we really need to call this?
+	if (error) {
+		tp->t_sc = NULL;
+	}
+	return (error);
+}
+
+/* clean up and set the tty back to termios. */
+int
+kissclose(struct tty *tp, int flags, struct proc *p)
+{
+	struct kiss_softc *sc = (struct kiss_softc *)tp->t_sc;
+	sc->sc_devp = NULL;
+	//free(sc, M_DEVBUF, sizeof(*sc));
+	// TODO: the sc is owned by if_kiss.c, make sure we free it there
+	kissreturn(tp); /* return TNC from KISS mode */
+	tp->t_line = TTYDISC;	/* switch back to termios */
+	tp->t_sc = NULL;
+	return (linesw[TTYDISC].l_close(tp, flags, p));
+	// TODO: do we really need to call this?
+}
+
+/* send command to tnc to exit kiss mode. */
+void
+kissreturn(struct tty *tp)
+{
+	putc(KISSCMD_RETURN, &tp->t_outq);
+}
+
+/* tty input interrupt handler. collects kiss frames. */
+int
+kissinput(int c, struct tty *tp)
+{
+	struct kiss_softc *sc = (struct kiss_softc *)tp->t_sc;
+
+	if (c == KISSFEND) {
+		if (sc->sc_flags & KISSSC_DATA && sc->pos > 14)
+			kissinputdone(sc);
+		sc->sc_flags = KISSSC_NEW;
+		return 0;
+	}
+
+	if (sc->sc_flags & KISSSC_NEW) {
+		/* this is the first byte in a new frame. */
+		int port = (c & 0xF0) >> 4;
+		int command = c & 0x0F;
+
+		sc->sc_flags = 0;
+
+		switch (command) {
+		case KISSCMD_DATA:
+			printf("data command received on port %d\n", port);
+			sc->port = port;
+			sc->pos = 0;
+			sc->sc_flags |= KISSSC_DATA;
+			break;
+		default:
+			printf("unrecognised command received on port %d\n", port);
+			break;
+		}
+		return 0;
+	}
+
+	if (c == KISSFESC) {
+		sc->sc_flags |= KISSSC_ESCAPE;
+		return 0;
+	}
+
+	if (sc->sc_flags & KISSSC_ESCAPE) {
+		int escaped = 0;
+		switch (c) {
+		case KISSTFESC:
+			escaped = KISSFESC;
+			break;
+		case KISSTFEND:
+			escaped = KISSFEND;
+			break;
+		}
+		if (escaped) {
+			c = escaped;
+		} else {
+			/* abort this packet. */
+			sc->sc_flags &= ~KISSSC_DATA;
+		}
+		sc->sc_flags &= ~KISSSC_ESCAPE;
+	}
+
+	if (sc->sc_flags & KISSSC_DATA) {
+		if (sc->pos < (KISSMAX - 1)) {
+			sc->cbuf[sc->pos++] = c;
+		} else {
+			/* abort the packet. */
+			sc->sc_flags &= ~KISSSC_DATA;
+		}
+	}
+	return 0;
+}
+
+void
+kissinputdone(struct kiss_softc *sc) {
+	struct mbuf *m = m_devget(sc->cbuf, sc->pos, 0);
+	if_vinput(&sc->sc_if, m);
+}
+
+/* output a kiss frame with packet data from an mbuf. */
+void
+kissoutput(struct kiss_softc *sc, struct mbuf *m) {
+	int s;
+	register u_char *cp;
+	struct tty *tp = (struct tty *)sc->sc_devp;
+
+	smr_read_enter(); // TODO: what is this protecting?
+	s = spltty();
+	putc(KISSFEND, &tp->t_outq);
+	putc(KISSCMD_DATA, &tp->t_outq); /* implicitly port 0 */
+
+	while (m) {
+		register u_char *ep;
+
+		cp = mtod(m, u_char *); ep = cp + m->m_len;
+		while (cp < ep) {
+			/*
+			 * Find out how many bytes in the string we can
+			 * handle without doing something special.
+			 */
+			register u_char *bp = cp;
+
+			while (cp < ep) {
+				switch (*cp++) {
+				case KISSFESC:
+				case KISSFEND:
+					--cp;
+					goto out;
+				}
+			}
+			out:
+			if (cp > bp) {
+				/*
+				 * Put n characters at once
+				 * into the tty output queue.
+				 */
+				if (b_to_q((char *)bp, cp - bp,
+				    &tp->t_outq))
+					break;
+				sc->sc_if.if_obytes += cp - bp;
+			}
+			/*
+			 * If there are characters left in the mbuf,
+			 * the first one must be special..
+			 * Put it out in a different form.
+			 */
+			if (cp < ep) {
+				if (putc(KISSFESC, &tp->t_outq))
+					break;
+				if (putc(*cp++ == KISSFESC ?
+				   KISSTFESC : KISSTFEND,
+				   &tp->t_outq)) {
+					(void) unputc(&tp->t_outq);
+					break;
+				}
+				sc->sc_if.if_obytes += 2;
+			}
+		}
+		m = m_free(m);
+	}
+
+	putc(KISSFEND, &tp->t_outq);
+	splx(s);
+	ttstart(tp);
+	smr_read_leave();
+}
+
+/* allocate the first available network interface. */
+struct kiss_softc *
+kissalloc(pid_t pid)
+{
+	struct kiss_softc *sc;
+
+	NET_LOCK();
+	LIST_FOREACH(sc, &kiss_softc_list, sc_list) {
+		if (sc->sc_xfer == pid) {
+			sc->sc_xfer = 0;
+			NET_UNLOCK();
+			return sc;
+		}
+	}
+	LIST_FOREACH(sc, &kiss_softc_list, sc_list) {
+		if (sc->sc_devp == NULL)
+			break;
+	}
+	NET_UNLOCK();
+	if (sc == NULL)
+		return NULL;
+
+	return sc;
+}
+
+/* register a kiss interface with the line discipline. */
+void
+kissregister(struct kiss_softc *sc)
+{
+	NET_LOCK();
+	LIST_INSERT_HEAD(&kiss_softc_list, sc, sc_list);
+	NET_UNLOCK();
+}
Index: src/sys/sys/tty.h
===================================================================
--- src.orig/sys/sys/tty.h
+++ src/sys/sys/tty.h
@@ -333,4 +333,9 @@ int	endrunopen(dev_t, struct tty *, stru
 int	endrunclose(struct tty *, int, struct proc *);
 int	endruninput(int, struct tty *);
 
+int	kissopen(dev_t, struct tty *, struct proc *);
+int	kissclose(struct tty *, int, struct proc *);
+int	kissinput(int, struct tty *);
+int	kissstart(struct tty *);
+
 #endif /* _KERNEL */
Index: src/sys/sys/ttycom.h
===================================================================
--- src.orig/sys/sys/ttycom.h
+++ src/sys/sys/ttycom.h
@@ -147,5 +147,6 @@ struct tstamps {
 #define	NMEADISC	7		/* NMEA0183 discipline */
 #define	MSTSDISC	8		/* Meinberg time string discipline */
 #define	ENDRUNDISC	9		/* EndRun time format discipline */
+#define	KISSDISC	10		/* KISS TNC discipline */
 
 #endif /* !_SYS_TTYCOM_H_ */
Index: src/share/man/man4/ekiss.4
===================================================================
--- /dev/null
+++ src/share/man/man4/ekiss.4
@@ -0,0 +1,82 @@
+.\"	$OpenBSD$
+.\"
+.\" Copyright (c) 1983, 1991, 1993
+.\"	The Regents of the University of California.  All rights reserved.
+.\" Copyright (c) 2019 Iain R. Leamonth <irl@fsfe.org>
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. Neither the name of the University nor the names of its contributors
+.\"    may be used to endorse or promote products derived from this software
+.\"    without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\"     From:	@(#)lo.4	8.1 (Berkeley) 6/5/93
+.\"
+.Dd $Mdocdate: September 01 2019 $
+.Dt KISS 4
+.Os
+.Sh NAME
+.Nm ekiss
+.Nd Ethernet-over-KISS network interface
+.Sh SYNOPSIS
+.Cd "pseudo-device ekiss"
+.Sh DESCRIPTION
+The
+.Nm
+interface allows serial lines to be used as network interfaces using the
+.Em KISS protocol.
+.Pp
+A
+.Nm
+interface can be created at runtime using the
+.Ic ifconfig kiss Ns Ar N Ic create
+command or by setting up a
+.Xr hostname.if 5
+configuration file for
+.Xr netstart 8 .
+.Sh SEE ALSO
+.Xr inet 4 ,
+.Xr ldattach 8 ,
+.Xr hostname.if 5 ,
+.Xr ifconfig 8 ,
+.Xr netstart 8
+.Sh STANDARDS
+.Bl -bullet
+.It
+.Rs
+.%A Mike Chepponis, K3MC
+.%A Phil Karn, KA9Q
+.%D 1987
+.%T The KISS TNC: A simple Host-to-TNC communications protocol
+.%B ARRL 6th Computer Networking Conference
+.%C Redondo Beach, CA, United States.
+.Re
+.It
+.Rs
+.%A Karl Medcalf, WK5M
+.%D 1991
+.%T Multi-Drop KISS operation
+.%B ARRL 10th Computer Networking Conference
+.%C San Jose, CA, United States.
+.Re
+.El
+.Sh BUGS
+Currently, too many to enumerate. Look out for TODO: entries in the codebase.
