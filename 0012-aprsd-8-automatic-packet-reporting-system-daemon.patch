From 8bba8772abf526659bd780dff888c435f79cd945 Mon Sep 17 00:00:00 2001
From: "Iain R. Learmonth" <irl@fsfe.org>
Date: Sat, 23 Nov 2019 22:55:51 +0000
Subject: [PATCH 12/13] aprsd(8): automatic packet reporting system daemon

---
 etc/Makefile                |   2 +-
 etc/rc                      |   2 +-
 etc/rc.conf                 |   1 +
 etc/rc.d/aprsd              |  11 +
 usr.sbin/Makefile           |   2 +-
 usr.sbin/aprsd/Makefile     |   9 +
 usr.sbin/aprsd/aprsd.8      |  86 +++++
 usr.sbin/aprsd/aprsd.c      | 547 +++++++++++++++++++++++++++++++
 usr.sbin/aprsd/aprsd.conf.5 | 140 ++++++++
 usr.sbin/aprsd/aprsd.h      |  35 ++
 usr.sbin/aprsd/gps.c        |  68 ++++
 usr.sbin/aprsd/gps.h        |   7 +
 usr.sbin/aprsd/parse.y      | 625 ++++++++++++++++++++++++++++++++++++
 13 files changed, 1532 insertions(+), 3 deletions(-)
 create mode 100644 etc/rc.d/aprsd
 create mode 100644 usr.sbin/aprsd/Makefile
 create mode 100644 usr.sbin/aprsd/aprsd.8
 create mode 100644 usr.sbin/aprsd/aprsd.c
 create mode 100644 usr.sbin/aprsd/aprsd.conf.5
 create mode 100644 usr.sbin/aprsd/aprsd.h
 create mode 100644 usr.sbin/aprsd/gps.c
 create mode 100644 usr.sbin/aprsd/gps.h
 create mode 100644 usr.sbin/aprsd/parse.y

diff --git a/etc/Makefile b/etc/Makefile
index 4f378fd4f6f..6839285768f 100644
--- a/etc/Makefile
+++ b/etc/Makefile
@@ -57,7 +57,7 @@ EXAMPLES_600=bgpd.conf doas.conf dvmrpd.conf eigrpd.conf hostapd.conf \
 	ripd.conf sasyncd.conf snmpd.conf vm.conf ypldap.conf
 
 # -r-xr-xr-x
-RCDAEMONS=amd apmd bgpd bootparamd cron dhcpd dhcrelay dhcrelay6 dvmrpd \
+RCDAEMONS=amd apmd aprsd bgpd bootparamd cron dhcpd dhcrelay dhcrelay6 dvmrpd \
 	eigrpd ftpd ftpproxy ftpproxy6 hostapd hotplugd httpd iclcd identd ifstated \
 	iked inetd isakmpd iscsid ldapd ldattach ldomd ldpd lockd \
 	lpd mopd mountd mrouted nfsd npppd nsd ntpd ospf6d ospfd \
diff --git a/etc/rc b/etc/rc
index 90731e1e841..f2b7f202460 100644
--- a/etc/rc
+++ b/etc/rc
@@ -585,7 +585,7 @@ start_daemon ldomd sshd switchd snmpd ldpd ripd ospfd ospf6d bgpd ifstated
 start_daemon relayd dhcpd dhcrelay mrouted dvmrpd radiusd eigrpd route6d
 start_daemon rad hostapd lpd smtpd slowcgi httpd ftpd
 start_daemon ftpproxy ftpproxy6 tftpd tftpproxy identd inetd rarpd bootparamd
-start_daemon rbootd mopd vmd spamd spamlogd sndiod iclcd
+start_daemon rbootd mopd vmd spamd spamlogd sndiod aprsd iclcd
 echo '.'
 
 # If rc.firsttime exists, run it just once, and make sure it is deleted.
diff --git a/etc/rc.conf b/etc/rc.conf
index baad5ed773d..d0c5e4857c1 100644
--- a/etc/rc.conf
+++ b/etc/rc.conf
@@ -14,6 +14,7 @@
 # Set them to "" to run them with the default flags.
 # Otherwise, these variables override the default flags.
 apmd_flags=NO
+aprsd_flags=NO
 bgpd_flags=NO
 bootparamd_flags=NO
 cron_flags=
diff --git a/etc/rc.d/aprsd b/etc/rc.d/aprsd
new file mode 100644
index 00000000000..47e93f59852
--- /dev/null
+++ b/etc/rc.d/aprsd
@@ -0,0 +1,11 @@
+#!/bin/ksh
+#
+# $OpenBSD$
+
+daemon="/usr/sbin/aprsd"
+
+. /etc/rc.d/rc.subr
+
+rc_reload=NO
+
+rc_cmd $1
diff --git a/usr.sbin/Makefile b/usr.sbin/Makefile
index f7f20012a85..a7f76f73800 100644
--- a/usr.sbin/Makefile
+++ b/usr.sbin/Makefile
@@ -2,7 +2,7 @@
 
 .include <bsd.own.mk>
 
-SUBDIR=	ac accton acme-client acpidump adduser amd apm apmd arp \
+SUBDIR=	ac accton acme-client acpidump adduser amd apm apmd aprsd arp \
 	authpf bgpctl bgpd bind chroot config cron crunchgen dev_mkdb \
 	dhcpd dhcrelay dhcrelay6 dvmrpctl dvmrpd edquota eeprom eigrpd eigrpctl \
 	fdformat ftp-proxy gpioctl hostapd hostctl hotplugd httpd iclcd identd \
diff --git a/usr.sbin/aprsd/Makefile b/usr.sbin/aprsd/Makefile
new file mode 100644
index 00000000000..476cd1deaed
--- /dev/null
+++ b/usr.sbin/aprsd/Makefile
@@ -0,0 +1,9 @@
+#	$OpenBSD: Makefile,v 1.8 2015/03/11 14:59:04 deraadt Exp $
+
+PROG=	aprsd
+SRCS=	aprsd.c gps.c parse.y
+MAN=	aprsd.conf.5 aprsd.8
+
+CFLAGS= -I${.CURDIR}
+
+.include <bsd.prog.mk>
diff --git a/usr.sbin/aprsd/aprsd.8 b/usr.sbin/aprsd/aprsd.8
new file mode 100644
index 00000000000..f417e80bc47
--- /dev/null
+++ b/usr.sbin/aprsd/aprsd.8
@@ -0,0 +1,86 @@
+.Dd October 11, 2019
+.Dt APRSD 8
+.Os
+.Sh NAME
+.Nm aprsd
+.Nd Automatic Packet Reporting System daemon
+.Sh SYNOPSIS
+.Nm
+.Op Fl DG
+.Op Fl g Ar sensor
+.Op Fl i Ar interface
+.Op Fl p Ar period
+.Op Fl l Ar latitude
+.Op Fl L Ar longitude
+.Sh DESCRIPTION
+.Nm
+sends
+.Em APRS
+position reports using either GPS or user-supplied position information.
+.Pp
+.Nm
+is usually started at boot time, and can be enabled by
+setting the following in
+.Pa /etc/rc.conf.local :
+.Pp
+.Dl aprsd_flags=\&"\&"
+.Pp
+See
+.Xr rc 8
+and
+.Xr rc.conf 8
+for more information on the boot process
+and enabling daemons.
+.Pp
+.Nm
+is configured using the
+.Xr aprsd.conf 5
+configuration file.
+This defines the beacons to be sent periodically, and filter rules for
+digipeater functionality.
+The callsign found in
+.Xr mycallsign 5
+will be used as the originating address for position beacons.
+The SSID is hardcoded as -6 for now.
+.Pp
+APRS uses
+.Em AX.25
+as a link layer, which restricts callsign length to at most 6 characters.
+If your callsign is longer than 6 characters then
+.Nm
+will refuse to start.
+.Pp
+The
+.Xr nmea 4
+driver can be used to provide a live GPS position.
+Other drivers that update the sensors framework may also work.
+.Pp
+If the sensor cannot be found, or the sensor does not have a valid latitude or
+longitude, but a fixed latitude and longitude were provided, then the fixed
+position will be used.
+If no fixed position was provided, beacons are disabled until the sensor
+provides a valid position again.
+.Sh OPTIONS
+.Bl -tag -width Ds
+.It Fl D
+Do not daemonize.
+.It Fl i Ar interface
+Interface name to broadcast position reports (default: axkiss0).
+.El
+.Sh SEE ALSO
+.Xr nmea 4 ,
+.Xr aprsd.conf 5 ,
+.Xr mycallsign 5
+.Sh HISTORY
+.Nm
+first appeared in HamBSD XXX.
+.Sh AUTHORS
+The
+.Nm
+daemon was written for the HamBSD project by
+.An Iain R. Learmonth Aq Mt irl@fsfe.org
+for the public domain.
+.Sh CAVEATS
+It is not currently possible to broadcast position reports on multiple
+interfaces with a single instance.
+It is however possible to manually start multiple instances.
diff --git a/usr.sbin/aprsd/aprsd.c b/usr.sbin/aprsd/aprsd.c
new file mode 100644
index 00000000000..ef48c217769
--- /dev/null
+++ b/usr.sbin/aprsd/aprsd.c
@@ -0,0 +1,547 @@
+/*
+ * aprsd - automatic packet reporting system daemon
+ *
+ * Written by Iain R. Learmonth <irl@fsfe.org> for the public domain.
+ */
+
+#include <err.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <sys/event.h>
+#include <sys/ioctl.h>
+#include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <net/bpf.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include "aprsd.h"
+#include "gps.h"
+
+struct aprs_interface {
+	int		 ai_fd;		/* file descriptor */
+	int		 ai_rbufsize;	/* receive buffer size */
+	char		*ai_name;	/* interface name, (e.g. axtap0) */
+};
+
+struct aprs_beacon_attrs {
+	long long	 fixed_lon;	/* fixed longitude if no GPS */
+	long long	 fixed_lat;	/* fixed latitude if no GPS */
+	time_t		 next_time;	/* next beacon time */
+	int		 interval;	/* beacon period */
+	int		 flags;		/* aprsd.h: BEACONF_* */
+	int		 ssid;		/* SSID, 0-15 */
+	int		 type;		/* aprsd.h: BEACONT_* */
+	char		*call;		/* callsign as ascii text */
+	char		*comment;	/* comment text */
+	char		*name;		/* object/item name */
+	char		*sensor;	/* gps sensor name (e.g. nmea0) */
+};
+
+static __dead void		 fatal(char *);
+static __dead void		 usage(void);
+static void			 signal_handler(int);
+static char 			*aprs_lat_ntoa(long long);
+static char 			*aprs_lon_ntoa(long long);
+static char			*read_mycallsign(void);
+static struct aprs_interface	*aprs_lookup_interface(int);
+static int			 aprs_compose(char *, struct aprs_beacon_attrs *);
+static struct aprs_interface	*aprs_open(char *);
+static void			 daemonize();
+static void			*aprs_beacon_loop(int, struct aprs_beacon_attrs *[]);
+
+struct aprs_interface *aifs[20];
+int naifs = 0;
+
+static __dead void
+fatal(char* msg)
+{
+	syslog(LOG_DAEMON | LOG_ERR,
+	    "%s", msg);
+	exit(1);
+}
+
+static __dead void
+usage(void)
+{
+	extern char *__progname;
+
+	fprintf(stderr, "usage: %s [-D] [-s] [-f file] [if0 [... ifN]]\n",
+	    __progname);
+	exit(1);
+}
+
+static void
+signal_handler(int sig)
+{
+	switch(sig) {
+	case SIGHUP:
+		syslog(LOG_DAEMON | LOG_INFO, "caught hangup signal");
+		break;
+	case SIGTERM:
+		syslog(LOG_DAEMON | LOG_EMERG,
+		    "caught terminate signal, shutting down");
+		exit(0);
+		break;
+	}
+}
+
+static char *
+aprs_lat_ntoa(long long udeg)
+{
+	static char buf[9];
+	long deg, rem, umnt, mnt, dmt;
+	int north;
+	if (udeg < 0) {
+		udeg *= -1;
+		north = 0;
+	} else {
+		north = 1;
+	}
+	deg = udeg / 1000000;
+	snprintf(buf, 3, "%02ld", deg);
+	umnt = udeg % 1000000 * 60;
+	mnt = umnt / 1000000;
+	snprintf(&buf[2], 3, "%02ld", mnt);
+	buf[4] = '.';
+	dmt = umnt % 1000000;
+	snprintf(&buf[5], 3, "%02ld", dmt);
+	if (north) {
+		buf[7] = 'N';
+	} else {
+		buf[7] = 'S';
+	}
+	buf[8] = '\0';
+	return buf;
+}
+
+static char *
+aprs_lon_ntoa(long long udeg)
+{
+	static char buf[10];
+	long deg, rem, umnt, mnt, dmt;
+	int east;
+	if (udeg < 0) {
+		udeg *= -1;
+		east = 0;
+	} else {
+		east = 1;
+	}
+	deg = udeg / 1000000;
+	snprintf(buf, 4, "%03ld", deg);
+	umnt = udeg % 1000000 * 60;
+	mnt = umnt / 1000000;
+	snprintf(&buf[3], 3, "%02ld", mnt);
+	buf[5] = '.';
+	dmt = umnt % 1000000;
+	snprintf(&buf[6], 3, "%02ld", dmt);
+	if (east) {
+		buf[8] = 'E';
+	} else {
+		buf[8] = 'W';
+	}
+	buf[9] = '\0';
+	return buf;
+}
+
+static char *
+read_mycallsign(void)
+{
+	static char fcall[20];
+	FILE    *mcp;
+	char    *call, *nl;
+	size_t  callsize = 0;
+	ssize_t calllen;
+
+	call = NULL;
+
+	if ((mcp = fopen("/etc/mycallsign", "r")) == NULL)
+		fatal("could not open /etc/mycallsign");
+	if ((calllen = getline(&call, &callsize, mcp)) != -1) {
+		if ((nl = strchr(call, '\n')) != NULL)
+			nl[0] = '\0';
+		return call;
+	}
+	fatal("could not read callsign from /etc/mycallsign");
+}
+
+static struct aprs_interface *
+aprs_lookup_interface(int fd)
+{
+	int i;
+	for (i = 0; i < naifs; i++)
+		if (aifs[i]->ai_fd == fd)
+			return aifs[i];
+	return NULL;
+}
+
+static const char pon_hdr[] = {
+	'A' << 1, 'P' << 1, 'B' << 1, 'S' << 1, 'D' << 1, 'D' << 1, 0x60, /* destination */
+	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xed,	/* source */
+	0x03,						/* ui frame */
+	0xf0,						/* no layer 3 */
+	'!',						/* position report, no timestamp */
+	0, 0, 0, 0, 0, 0, 0, 0,				/* latitude */
+	'/',						/* table */
+	0, 0, 0, 0, 0, 0, 0, 0, 0,			/* longitude */
+	'/',						/* symbol */
+};
+static const int pon_hdr_size = sizeof(pon_hdr);
+
+static const char pot_hdr[] = {
+	'A' << 1, 'P' << 1, 'B' << 1, 'S' << 1, 'D' << 1, 'D' << 1, 0x60, /* destination */
+	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xed,	/* source */
+	0x03,						/* ui frame */
+	0xf0,						/* no layer 3 */
+	'/',						/* position report, with timestamp */
+	0, 0, 0, 0, 0, 0, 'z',				/* timestamp */
+	0, 0, 0, 0, 0, 0, 0, 0,				/* latitude */
+	'/',						/* symbol table */
+	0, 0, 0, 0, 0, 0, 0, 0, 0,			/* longitude */
+	'/',						/* symbol */
+};
+static const int pot_hdr_size = sizeof(pot_hdr);
+
+static const char obj_hdr[] = {
+	'A' << 1, 'P' << 1, 'B' << 1, 'S' << 1, 'D' << 1, 'D' << 1, 0x60, /* destination */
+	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xed,	/* source */
+	0x03,						/* ui frame */
+	0xf0,						/* no layer 3 */
+	';',						/* object report */
+	' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',	/* object name */
+	'_',						/* object live */
+	0, 0, 0, 0, 0, 0, 'z',				/* timestamp */
+	0, 0, 0, 0, 0, 0, 0, 0,				/* latitude */
+	'/',						/* symbol table */
+	0, 0, 0, 0, 0, 0, 0, 0, 0,			/* longitude */
+	'/'						/* symbol */
+};
+static const int obj_hdr_size = sizeof(obj_hdr);
+
+/*
+ * Composes an APRS position report. The length of the composed frame is
+ * returned. The provided buf must be at least APRS_MAXLEN bytes in size.
+ *
+ * TODO: APRS_MAXLEN, 256 bytes is the maximum size of a UI frame payload, but
+ * the buf here also contains the header. I don't know if the payload size
+ * decreases as the path increases. It is possible we could have longer packets
+ * but there are also going to be a large number of radios that would not
+ * support them.
+ */
+static int
+aprs_compose(char *buf, struct aprs_beacon_attrs *attrs)
+{
+	struct gps_position pos;
+	time_t now;
+	char *lat, *lon, *name, timestamp[7];
+	int calllen, commentlen, pktlen, i;
+
+	if (attrs->sensor != NULL && gps_get_position(&pos, attrs->sensor) == 2) {
+		lat = strdup(aprs_lat_ntoa(pos.lat));
+		lon = strdup(aprs_lon_ntoa(pos.lon));
+	} else if ((attrs->flags & BEACONF_POSSET) == BEACONF_POSSET) {
+		lat = strdup(aprs_lat_ntoa(attrs->fixed_lat));
+		lon = strdup(aprs_lon_ntoa(attrs->fixed_lon));
+	} else {
+		return 0;
+	}
+
+	time(&now);
+	strftime(timestamp, 7, "%d%H%M", gmtime(&now));
+
+	switch (attrs->type) {
+	case BEACONT_PON:
+		pktlen = pon_hdr_size;
+		memcpy(buf, pon_hdr, pktlen);
+		memcpy(&buf[17], lat, 8);
+		memcpy(&buf[26], lon, 9);
+		break;
+	case BEACONT_POT:
+		pktlen = pot_hdr_size;
+		memcpy(buf, pot_hdr, pktlen);
+		memcpy(&buf[17], timestamp, 6);
+		memcpy(&buf[24], lat, 8);
+		memcpy(&buf[33], lon, 9);
+		break;
+	case BEACONT_OBJ:
+		pktlen = obj_hdr_size;
+		memcpy(buf, obj_hdr, pktlen);
+		memcpy(&buf[17], attrs->name, strlen(attrs->name));
+		memcpy(&buf[27], timestamp, 6);
+		memcpy(&buf[34], lat, 8);
+		memcpy(&buf[43], lon, 9);
+		break;
+	default:
+		/* TODO: unknown type */
+		return 0;
+	}
+
+	free(lat);
+	free(lon);
+
+	calllen = strlen(attrs->call);
+	if (calllen > 6) {
+		fatal("callsign in /etc/mycallsign too long");
+	}
+	for (i = 0; i < calllen; i++)
+		buf[7 + i] = attrs->call[i] << 1;
+	buf[13] = (attrs->ssid << 1) | 0xe1;
+
+	if (attrs->comment != NULL) {
+		commentlen = strlen(attrs->comment);
+		if (commentlen < APRS_MAXLEN - pktlen) { /* TODO: could be less than or equal? went conservative */
+			memcpy(&buf[pktlen], attrs->comment, commentlen);
+			pktlen += commentlen;
+		} else {
+			/* TODO: comment too big */
+			return 0;
+		}
+	}
+
+	return pktlen;
+}
+
+/*
+ * Open a BPF file and attach it to the interface named 'device'.
+ * Set immediate mode.
+ */
+struct aprs_interface *
+aprs_open(char *device)
+{
+	int iflen, yes;
+	struct ifreq bound_if;
+	u_int dlt;
+	struct aprs_interface *aif;
+
+	aif = malloc(sizeof(struct aprs_interface));
+	aif->ai_name = device;
+
+	if ((aif->ai_fd = open("/dev/bpf", O_RDWR)) == -1)
+		fatal("/dev/bpf failed to open");
+
+	yes = 1;
+
+	/* Set immediate mode to process packets as they arrive. */
+	if (ioctl(aif->ai_fd, BIOCIMMEDIATE, &yes) == -1)
+		fatal("failed to set immediate mode");
+
+	/* Set header complete mode to not override source address. */
+	if (ioctl(aif->ai_fd, BIOCSHDRCMPLT, &yes) == -1)
+		fatal("could not set header complete mode");
+
+	/* Bind the network interface. */
+	iflen = strlen(device);
+	if (strlcpy(bound_if.ifr_name, device, sizeof(bound_if.ifr_name))
+	    < iflen)
+		fatal("interface name too long");
+	if (ioctl(aif->ai_fd, BIOCSETIF, (caddr_t)&bound_if) == -1)
+		fatal("could not bind to interface");
+
+	if (ioctl(aif->ai_fd, BIOCGBLEN, (caddr_t)&aif->ai_rbufsize) == -1)
+		fatal("failed to get buffer size for bpf");
+
+	if (ioctl(aif->ai_fd, BIOCPROMISC, NULL) == -1)
+		fatal("could not set promiscuous mode");
+
+	return aif;
+}
+
+static void
+daemonize()
+{
+	int i;
+	i = daemon(0, 0);
+	signal(SIGCHLD, SIG_IGN); /* ignore child */
+	signal(SIGTSTP, SIG_IGN); /* ignore tty signals */
+	signal(SIGTTOU, SIG_IGN);
+	signal(SIGTTIN, SIG_IGN);
+	signal(SIGHUP, signal_handler); /* catch hangup signal */
+	signal(SIGTERM, signal_handler); /* catch kill signal */
+}
+
+void
+aprs_digipeat(char* pkt, int pktlen, struct aprs_interface *src)
+{
+	write(aifs[0]->ai_fd, pkt, pktlen);
+	/* TODO: so much error handling */
+}
+
+static void *
+aprs_beacon_loop(int num_beacons, struct aprs_beacon_attrs *beacons[])
+{
+	struct kevent chlist[10];
+	struct kevent evlist[10];
+	char framebuf[9000];
+	int bi, ii, evi, framelen, kq, nev, nr;
+	struct aprs_interface *aif;
+
+	if ((kq = kqueue()) == -1)
+		fatal("failed to create kqueue");
+
+	EV_SET(&chlist[0], 1, EVFILT_TIMER, EV_ADD | EV_ENABLE, 0, 1000, 0);
+
+	for (ii = 0; ii < naifs; ii++)
+		EV_SET(&chlist[ii + 1], aifs[ii]->ai_fd, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, 0);
+
+	syslog(LOG_DAEMON | LOG_INFO,
+	    "started up beacon loop (callsign: %s)", beacons[0]->call);
+
+	while ((nev = kevent(kq, chlist, naifs + 1, evlist, naifs + 1, NULL)) > 0) {
+		for (evi = 0; evi < nev; evi++) {
+			if (evlist[evi].filter != EVFILT_TIMER) {
+				char *bp, *ep;
+				aif = aprs_lookup_interface(evlist[evi].ident);
+				if ((nr = read(aif->ai_fd, framebuf, aif->ai_rbufsize)) == -1)
+					fatal("read");
+				if (aif != aifs[0]) {
+					bp = framebuf;
+					ep = bp + nr;
+					while (bp < ep) {
+#define caplen ((struct bpf_hdr *)bp)->bh_caplen
+#define hdrlen ((struct bpf_hdr *)bp)->bh_hdrlen
+						aprs_digipeat(bp + hdrlen, caplen, aif);
+						bp += BPF_WORDALIGN(hdrlen + caplen);
+					}
+				}
+				continue;
+			}
+			time_t now;
+			time(&now);
+			for (bi = 0; bi < num_beacons; bi++) {
+				if (beacons[bi]->next_time <= now) {
+					framelen = aprs_compose(framebuf, beacons[bi]);
+					if (write(aifs[0]->ai_fd, &framebuf, framelen) != framelen)
+						syslog(LOG_DAEMON | LOG_ERR, "failed to send packet: %m");
+					beacons[bi]->next_time = now + beacons[bi]->interval;
+				}
+			}
+		}
+	}
+	fatal("kevent");
+}
+
+int
+main(int argc, char **argv)
+{
+	struct aprsd_config conf;
+	struct aprs_beacon_attrs *beacons[20];
+	int ci, daemon, skipdelay, ssid;
+	char ch, *conffile, *device;
+	const char *errstr;
+
+	conf.num_beacons = 0;
+
+	/* option defaults */
+	conffile = "/etc/aprsd.conf";
+	daemon = 1;
+	device = "axkiss0";
+	skipdelay = 0;
+	ssid = 0;
+
+	while ((ch = getopt(argc, argv, "DS:i:f:s")) != -1) {
+		switch (ch) {
+		case 'i':
+			device = optarg;
+			break;
+		case 'f':
+			conffile = optarg;
+		case 'D':
+			daemon = 0;
+			break;
+		case 's':
+			skipdelay = 1;
+			break;
+		case 'S':
+			ssid = strtonum(optarg, 0, 15, &errstr);
+			if (errstr) {
+				warnx("SSID is %s: %s", errstr, optarg);
+				usage();
+			}
+			break;
+		default:
+			usage();
+			break;
+		}
+	}
+	argc -= optind;
+	argv += optind;
+
+	if (argc == 0)
+		fatal("no interfaces specified");
+
+	if (parse_config(conffile, &conf) == -1)
+		fatal("could not parse config");
+
+	char *call = read_mycallsign();
+
+	/* Check for root privileges. */
+	if (geteuid())
+		fatal("need root privileges");
+
+	if (daemon)
+		daemonize();
+
+	for (naifs = 0; naifs < argc; naifs++)
+		aifs[naifs] = aprs_open(argv[naifs]);
+
+	if (unveil(NULL, NULL) == -1)
+		fatal("failed to unveil");
+	if (pledge("stdio cpath wpath", NULL) == -1)
+		fatal("failed to pledge");
+
+	if (conf.num_beacons == 0)
+		fatal("refusing to run without beacons defined");
+
+	for (ci = 0; ci < conf.num_beacons; ci++) {
+		struct beacon_config *bc = conf.beacons[ci];
+		struct aprs_beacon_attrs *ba = malloc(sizeof(struct aprs_beacon_attrs));
+		beacons[ci] = ba;
+		ba->type = bc->type;
+		switch (ba->type) {
+		case BEACONT_OBJ:
+			ba->name = bc->name;
+			/* fallthrough */
+		case BEACONT_POT:
+		case BEACONT_PON:
+			ba->flags = bc->flags;
+			ba->interval = bc->interval;
+			if (skipdelay)
+				ba->next_time = 0;
+			else
+				ba->next_time = time(NULL) + (bc->interval / 2);
+			if ((bc->flags & BEACONF_POSSET) == BEACONF_POSSET) {
+				if (bc->flags & BEACONF_SOUTH) {
+					ba->fixed_lat = 0 - bc->latitude;
+				} else {
+					ba->fixed_lat = bc->latitude;
+				}
+				if (bc->flags & BEACONF_WEST) {
+					ba->fixed_lon = 0 - bc->longitude;
+				} else {
+					ba->fixed_lon = bc->longitude;
+				}
+			}
+			ba->sensor = bc->sensor;
+			ba->comment = bc->comment;
+			ba->call = call;
+			ba->ssid = ssid;
+			break;
+		default:
+			fatal("unknown beacon type");
+		}
+	}
+	aprs_beacon_loop(conf.num_beacons, beacons);
+}
diff --git a/usr.sbin/aprsd/aprsd.conf.5 b/usr.sbin/aprsd/aprsd.conf.5
new file mode 100644
index 00000000000..bb812bbfa5b
--- /dev/null
+++ b/usr.sbin/aprsd/aprsd.conf.5
@@ -0,0 +1,140 @@
+.\" Copyright (c) 2019 Iain R. Learmonth.
+.\" Copyright (c) 2004 Claudio Jeker <claudio@openbsd.org>
+.\" Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+.\" Copyright (c) 2002 Daniel Hartmeier <dhartmei@openbsd.org>
+.\"
+.\" Permission to use, copy, modify, and distribute this software for any
+.\" purpose with or without fee is hereby granted, provided that the above
+.\" copyright notice and this permission notice appear in all copies.
+.\"
+.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+.\"
+.Dd October 18, 2019
+.Dt APRSD.CONF 5
+.Os
+.Sh NAME
+.Nm aprsd.conf
+.Nd Automatic Packet Reporting System daemon configuration file
+.Sh DESCRIPTION
+The
+.Xr aprsd 8
+daemon implements an Automatic Packet Reporting System (APRS) tracker and
+digipeater.
+.Pp
+The
+.Nm
+config file is divided into the following main sections:
+.Bl -tag -width xxxx
+.It Sx MACROS
+User-defined variables may be defined and used later, simplifying the
+configuration file.
+.It Sx BEACON CONFIGURATION
+Periodic beacons for position and object reports are set in this section.
+.It Sx DIGIPEATER CONFIGURATION
+Filter rules for digipeating packets are set in this section.
+.El
+.Pp
+The current line can be extended over multiple lines using a backslash
+.Pq Sq \e .
+Comments can be put anywhere in the file using a hash mark
+.Pq Sq # ,
+and extend to the end of the current line.
+Care should be taken when commenting out multi-line text:
+the comment is effective until the end of the entire block.
+.Pp
+Argument names not beginning with a letter, digit, or underscore
+must be quoted.
+.Sh MACROS
+Macros can be defined that will later be expanded in context.
+Macro names must start with a letter, digit, or underscore,
+and may contain any of those characters.
+Macro names may not be reserved words (for example,
+.Ic beacon ,
+.Ic sensor ,
+or
+.Ic longitude ) .
+Macros are not expanded inside quotes.
+.Pp
+For example:
+.Bd -literal -offset indent
+gps="nmea0"
+beacon position sensor $gps
+.Ed
+.Sh BEACON CONFIGURATION
+These define beacons to be transmitted periodically by
+.Xr aprsd 8 .
+.Bl -tag -width Ds
+.It Xo
+.Ic beacon Cm position Op Cm no-timestamp
+.Po
+.Cm sensor Ar sensor | Cm latitude Ar latitude Op Cm north | Cm south
+.Cm longitude Ar longitude Op Cm east | Cm west
+.Pc
+.Op Cm comment Ar comment
+.Op Cm interval Ar interval
+.Xc
+.Pp
+Register a position beacon to be transmitted every
+.Ar interval
+seconds using either the GPS location given by
+.Ar sensor
+or the fixed
+.Ar latitude
+and
+.Ar longitude .
+Fixed positions
+.Pf ( Ar latitude
+and
+.Ar longitude )
+are given in microdegrees.
+To convert degrees to microdegrees simply multiply by 10^6.
+The number must be positive.
+To indicate a negative latitude or longitude, use the
+.Cm south
+or
+.Cm west
+keywords respectively.
+.Pp
+If the
+.Cm no-timestamp
+option is given then the beacon will use the format that does not contain a
+timestamp, which can be useful for machines that do not have a real-time clock.
+The comment can be set as a free-text field to be included in the position
+report.
+.It Xo
+.Ic beacon Cm object Cm name Ar name
+.Po
+.Cm sensor Ar sensor | Cm latitude Ar latitude Op Cm north | Cm south
+.Cm longitude Ar longitude Op Cm east | Cm west
+.Pc
+.Op Cm comment Ar comment
+.Op Cm interval Ar interval
+.Xc
+.Pp
+Register an object beacon.
+Most of the modifiers for an object beacon behave in the same way as for a
+position beacon.
+.Pp
+Every object beacon must have a name, which must be no more than 6 characters
+and contain only letters and numbers.
+The comment can be set as a free-text field to be included in the object position
+report.
+.El
+.Sh FILES
+.Bl -tag -width "/etc/aprsd.conf" -compact
+.It Pa /etc/aprsd.conf
+.El
+.Sh SEE ALSO
+.Xr ax25 4 ,
+.Xr aprsd 8 ,
+.Xr aprsisd 8
+.Sh HISTORY
+The
+.Nm
+file format first appeared in HamBSD XXX.
diff --git a/usr.sbin/aprsd/aprsd.h b/usr.sbin/aprsd/aprsd.h
new file mode 100644
index 00000000000..3055f5ae11f
--- /dev/null
+++ b/usr.sbin/aprsd/aprsd.h
@@ -0,0 +1,35 @@
+
+#define APRS_MAXLEN 256
+
+#define BEACONT_PON 1 /* position beacon, no timestamp */
+#define BEACONT_POT 2 /* position beacon, with timestamp */
+#define BEACONT_OBJ 3 /* object beacon */
+
+#define BEACONF_LATSET	0x01	/* a fixed latitude is defined */
+#define BEACONF_LONSET	0x02	/* a fixed longitude is defined */
+#define BEACONF_POSSET (BEACONF_LATSET | BEACONF_LONSET)
+#define BEACONF_ALTSET	0x04	/* a fixed altitude is defined */
+#define BEACONF_SOUTH	0x08	/* the fixed latitude is negative */
+#define BEACONF_WEST	0x10	/* the fixed longitude in negative */
+
+struct beacon_config {
+	long long latitude;
+	long long longitude;
+	long altitude;
+	int type;
+	int interval;
+	int flags;
+	char *comment;
+	char *name;
+	char *sensor;
+};
+
+#define MAX_BEACONS 20
+
+struct aprsd_config {
+	int num_beacons;
+	struct beacon_config *beacons[MAX_BEACONS];
+};
+
+/* parse.y */
+int parse_config(char *, struct aprsd_config *);
diff --git a/usr.sbin/aprsd/gps.c b/usr.sbin/aprsd/gps.c
new file mode 100644
index 00000000000..68cf2f6d73b
--- /dev/null
+++ b/usr.sbin/aprsd/gps.c
@@ -0,0 +1,68 @@
+
+#include <string.h>
+#include <err.h>
+#include <errno.h>
+
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/time.h>
+#include <sys/sensors.h>
+
+#include "gps.h"
+
+static struct sensordev *
+gps_find_sensor(char *name)
+{
+	int mib[3];
+	static struct sensordev sd;
+	size_t sdlen;
+
+	mib[0] = CTL_HW;
+	mib[1] = HW_SENSORS;
+	sdlen = sizeof(sd);
+	for (mib[2] = 0; ; mib[2]++) {
+		if (sysctl(mib, 3, &sd, &sdlen, NULL, 0) == -1) {
+			if (errno == ENXIO)
+				continue;
+			if (errno == ENOENT)
+				break;
+			err(1, "sysctl");
+		}
+		if (strcmp(name, sd.xname) == 0)
+			return &sd;
+	}
+	return NULL;
+}
+
+int
+gps_get_position(struct gps_position *pos, char *sensor_name)
+{
+	struct sensor s;
+	struct sensordev *sd;
+	int mib[5];
+	int lat, lon;
+	size_t slen;
+
+	lat = lon = 0;
+	slen = sizeof(s);
+	if ((sd = gps_find_sensor(sensor_name)) == NULL)
+		return 0;
+	mib[0] = CTL_HW;
+	mib[1] = HW_SENSORS;
+	mib[2] = sd->num;
+	mib[3] = SENSOR_ANGLE;
+	for (mib[4] = 0; mib[4] < sd->maxnumt[mib[3]]; mib[4]++) {
+		if (sysctl(mib, 5, &s, &slen, NULL, 0) == -1)
+			continue;
+		if (s.type == SENSOR_ANGLE && strcmp("Latitude", s.desc) == 0 &&
+		    s.status == SENSOR_S_OK) {
+			lat = 1;
+			pos->lat = s.value;
+		} else if (s.type == SENSOR_ANGLE && strcmp("Longitude", s.desc) == 0 &&
+		    s.status == SENSOR_S_OK) {
+			lon = 1;
+			pos->lon = s.value;
+		}
+	}
+	return lat + lon;
+}
diff --git a/usr.sbin/aprsd/gps.h b/usr.sbin/aprsd/gps.h
new file mode 100644
index 00000000000..5c9d8a404a2
--- /dev/null
+++ b/usr.sbin/aprsd/gps.h
@@ -0,0 +1,7 @@
+
+struct gps_position {
+	long long lat;
+	long long lon;
+};
+
+int gps_get_position(struct gps_position *, char *);
diff --git a/usr.sbin/aprsd/parse.y b/usr.sbin/aprsd/parse.y
new file mode 100644
index 00000000000..a4ab392a471
--- /dev/null
+++ b/usr.sbin/aprsd/parse.y
@@ -0,0 +1,625 @@
+/*	$OpenBSD: parse.y,v 1.18 2003/12/25 23:23:51 henning Exp $ */
+
+/*
+ * Copyright (c) 2019 Iain R. Learmonth.
+ * Copyright (c) 2002, 2003 Henning Brauer <henning@openbsd.org>
+ * Copyright (c) 2001 Markus Friedl.  All rights reserved.
+ * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
+ * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+%{
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <ctype.h>
+#include <err.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "aprsd.h"
+
+static struct aprsd_config	*conf;
+static struct beacon_config	*curbeacon;
+static FILE			*fin = NULL;
+static int			 lineno = 1;
+static int			 errors = 0;
+static int			 pdebug = 1;
+char				*infile;
+
+int	 yyerror(const char *, ...);
+int	 yyparse(void);
+int	 kw_cmp(const void *, const void *);
+int	 lookup(char *);
+int	 lgetc(FILE *);
+int	 lungetc(int);
+int	 findeol(void);
+int	 yylex(void);
+
+TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
+struct sym {
+	TAILQ_ENTRY(sym)	 entries;
+	int			 used;
+	int			 persist;
+	char			*nam;
+	char			*val;
+};
+
+int	 symset(const char *, const char *, int);
+char	*symget(const char *);
+int	 atoul(char *, u_long *);
+
+typedef struct {
+	union {
+		u_int32_t	 number;
+		char		*string;
+		struct in_addr	 addr;
+	} v;
+	int lineno;
+} YYSTYPE;
+
+%}
+
+%token	ALTITUDE BEACON COMMENT EAST INTERVAL LATITUDE LONGITUDE
+%token	NAME NORTH NO_TIMESTAMP OBJECT POSITION SENSOR SOUTH
+%token	WEST
+%token	<v.string>	STRING
+%type	<v.number>	number
+%type	<v.string>	string
+%type	<v.addr>	address
+%%
+
+grammar		: /* empty */
+		| grammar '\n'
+		| grammar conf_main '\n'
+		| grammar varset '\n'
+		| grammar error '\n'		{ errors++; }
+		;
+
+number		: STRING			{
+			u_long	ulval;
+
+			if (atoul($1, &ulval) == -1) {
+				yyerror("%s is not a number", $1);
+				YYERROR;
+			} else
+				$$ = ulval;
+		}
+		;
+
+string		: string STRING				{
+			if (asprintf(&$$, "%s %s", $1, $2) == -1)
+				err(1, "string: asprintf");
+			free($1);
+			free($2);
+		}
+		| STRING
+		;
+
+varset		: STRING '=' string		{
+			//if (conf->opts & BGPD_OPT_VERBOSE)
+			//	printf("%s = \"%s\"\n", $1, $3);
+			if (symset($1, $3, 0) == -1)
+				err(1, "cannot store variable");
+		}
+		;
+
+conf_main	: beacon
+		;
+
+beacon		: BEACON {
+			if (conf->num_beacons == MAX_BEACONS) {
+				yyerror("too many beacons defined");
+				YYERROR;
+			}
+			if ((conf->beacons[conf->num_beacons] =
+			    malloc(sizeof(struct beacon_config))) == NULL)
+				err(1, "malloc");
+			curbeacon = conf->beacons[conf->num_beacons];
+			curbeacon->comment = NULL;
+			curbeacon->name = NULL;
+			curbeacon->sensor = NULL;
+			curbeacon->flags = 0;
+			curbeacon->interval = 300;
+		} beacon_opts {
+			conf->num_beacons++;
+		}
+		;
+
+beacon_opts	: POSITION {
+			curbeacon->type = BEACONT_POT;
+		} beaposopts
+		| POSITION NO_TIMESTAMP {
+			curbeacon->type = BEACONT_PON;
+		} beaposopts
+		| OBJECT {
+			curbeacon->type = BEACONT_OBJ;
+		} beaobjopts
+		;
+
+beaposopts	: /* empty */
+		| beaposopts beaposopt
+		;
+
+beaobjopts	: /* empty */
+		| beaobjopts beaposopt
+		| beaobjopts NAME string {
+			curbeacon->name = strdup($3);
+		}
+		;
+
+beaposopt	: intervalopt
+		| sensoropt
+		| lonopt
+		| latopt
+		| commentopt
+		;
+
+intervalopt	: INTERVAL number	{
+			curbeacon->interval = $2;
+		}
+		;
+
+sensoropt	: SENSOR string		{
+			curbeacon->sensor = strdup($2);
+		}
+		;
+
+latopt		: LATITUDE number	{
+			curbeacon->flags |= BEACONF_LATSET;
+			curbeacon->latitude = $2;
+		} latdir
+		;
+
+latdir		: /* empty */
+		| NORTH {
+			curbeacon->flags &= ~BEACONF_SOUTH;
+		}
+		| SOUTH {
+			curbeacon->flags |= BEACONF_SOUTH;
+		}
+		;
+
+lonopt		: LONGITUDE number	{
+			curbeacon->flags |= BEACONF_LONSET;
+			curbeacon->longitude = $2;
+		} londir
+		;
+
+londir		: /* empty */
+		| EAST {
+			curbeacon->flags &= ~BEACONF_WEST;
+		}
+		| WEST {
+			curbeacon->flags |= BEACONF_WEST;
+		}
+		;
+
+commentopt	: COMMENT string	{
+			curbeacon->comment = strdup($2);
+		}
+		;
+
+address		: STRING		{
+			int	n;
+
+			if ((n = inet_pton(AF_INET, $1, &$$)) == -1) {
+				yyerror("inet_pton: %s", strerror(errno));
+				YYERROR;
+			}
+			if (n == 0) {
+				yyerror("could not parse address spec %s", $1);
+				YYERROR;
+			}
+		}
+		;
+
+optnl		: '\n' optnl
+		|
+		;
+
+%%
+
+struct keywords {
+	const char	*k_name;
+	int		 k_val;
+};
+
+int
+yyerror(const char *fmt, ...)
+{
+	va_list		 ap;
+	char		*nfmt;
+
+	errors = 1;
+	va_start(ap, fmt);
+	if (asprintf(&nfmt, "%s:%d: %s", infile, yylval.lineno, fmt) == -1)
+		err(1, "yyerror asprintf");
+	printf(nfmt, ap);
+	va_end(ap);
+	free(nfmt);
+	return (0);
+}
+
+int
+kw_cmp(const void *k, const void *e)
+{
+	return (strcmp(k, ((const struct keywords *)e)->k_name));
+}
+
+int
+lookup(char *s)
+{
+	/* this has to be sorted always */
+	static const struct keywords keywords[] = {
+		{ "altitude",		ALTITUDE },
+		{ "beacon",		BEACON },
+		{ "comment",		COMMENT },
+		{ "east",		EAST },
+		{ "interval",		INTERVAL },
+		{ "latitude",		LATITUDE },
+		{ "longitude",		LONGITUDE },
+		{ "name",		NAME },
+		{ "no-timestamp",	NO_TIMESTAMP },
+		{ "north",		NORTH },
+		{ "object",		OBJECT },
+		{ "position",		POSITION },
+		{ "sensor",		SENSOR },
+		{ "south",		SOUTH },
+		{ "west",		WEST },
+	};
+	const struct keywords	*p;
+
+	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
+	    sizeof(keywords[0]), kw_cmp);
+
+	if (p) {
+		if (pdebug > 1)
+			fprintf(stderr, "%s: %d\n", s, p->k_val);
+		return (p->k_val);
+	} else {
+		if (pdebug > 1)
+			fprintf(stderr, "string: %s\n", s);
+		return (STRING);
+	}
+}
+
+#define MAXPUSHBACK	128
+
+char	*parsebuf;
+int	 parseindex;
+char	 pushback_buffer[MAXPUSHBACK];
+int	 pushback_index = 0;
+
+int
+lgetc(FILE *f)
+{
+	int	c, next;
+
+	if (parsebuf) {
+		/* Read character from the parsebuffer instead of input. */
+		if (parseindex >= 0) {
+			c = parsebuf[parseindex++];
+			if (c != '\0')
+				return (c);
+			parsebuf = NULL;
+		} else
+			parseindex++;
+	}
+
+	if (pushback_index)
+		return (pushback_buffer[--pushback_index]);
+
+	while ((c = getc(f)) == '\\') {
+		next = getc(f);
+		if (next != '\n') {
+			if (isspace(next))
+				yyerror("whitespace after \\");
+			ungetc(next, f);
+			break;
+		}
+		yylval.lineno = lineno;
+		lineno++;
+	}
+	if (c == '\t' || c == ' ') {
+		/* Compress blanks to a single space. */
+		do {
+			c = getc(f);
+		} while (c == '\t' || c == ' ');
+		ungetc(c, f);
+		c = ' ';
+	}
+
+	return (c);
+}
+
+int
+lungetc(int c)
+{
+	if (c == EOF)
+		return (EOF);
+	if (parsebuf) {
+		parseindex--;
+		if (parseindex >= 0)
+			return (c);
+	}
+	if (pushback_index < MAXPUSHBACK-1)
+		return (pushback_buffer[pushback_index++] = c);
+	else
+		return (EOF);
+}
+
+int
+findeol(void)
+{
+	int	c;
+
+	parsebuf = NULL;
+	pushback_index = 0;
+
+	/* skip to either EOF or the first real EOL */
+	while (1) {
+		c = lgetc(fin);
+		if (c == '\n') {
+			lineno++;
+			break;
+		}
+		if (c == EOF)
+			break;
+	}
+	//return (ERROR);
+	return 250;
+}
+
+int
+yylex(void)
+{
+	char	 buf[8096];
+	char	*p, *val;
+	int	 endc, c;
+	int	 token;
+
+top:
+	p = buf;
+	while ((c = lgetc(fin)) == ' ')
+		; /* nothing */
+
+	yylval.lineno = lineno;
+	if (c == '#')
+		while ((c = lgetc(fin)) != '\n' && c != EOF)
+			; /* nothing */
+	if (c == '$' && parsebuf == NULL) {
+		while (1) {
+			if ((c = lgetc(fin)) == EOF)
+				return (0);
+
+			if (p + 1 >= buf + sizeof(buf) - 1) {
+				yyerror("string too long");
+				return (findeol());
+			}
+			if (isalnum(c) || c == '_') {
+				*p++ = (char)c;
+				continue;
+			}
+			*p = '\0';
+			lungetc(c);
+			break;
+		}
+		val = symget(buf);
+		if (val == NULL) {
+			yyerror("macro '%s' not defined", buf);
+			return (findeol());
+		}
+		parsebuf = val;
+		parseindex = 0;
+		goto top;
+	}
+
+	switch (c) {
+	case '\'':
+	case '"':
+		endc = c;
+		while (1) {
+			if ((c = lgetc(fin)) == EOF)
+				return (0);
+			if (c == endc) {
+				*p = '\0';
+				break;
+			}
+			if (c == '\n') {
+				lineno++;
+				continue;
+			}
+			if (p + 1 >= buf + sizeof(buf) - 1) {
+				yyerror("string too long");
+				return (findeol());
+			}
+			*p++ = (char)c;
+		}
+		yylval.v.string = strdup(buf);
+		if (yylval.v.string == NULL)
+			err(1, "yylex: strdup");
+		return (STRING);
+	}
+
+#define allowed_in_string(x) \
+	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
+	x != '{' && x != '}' && x != '<' && x != '>' && \
+	x != '!' && x != '=' && x != '/' && x != '#' && \
+	x != ','))
+
+	if (isalnum(c) || c == ':' || c == '_') {
+		do {
+			*p++ = c;
+			if ((unsigned)(p-buf) >= sizeof(buf)) {
+				yyerror("string too long");
+				return (findeol());
+			}
+		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
+		lungetc(c);
+		*p = '\0';
+		token = lookup(buf);
+		yylval.v.string = strdup(buf);
+		if (yylval.v.string == NULL)
+			err(1, "yylex: strdup");
+		return (token);
+	}
+	if (c == '\n') {
+		yylval.lineno = lineno;
+		lineno++;
+	}
+	if (c == EOF)
+		return (0);
+	return (c);
+}
+
+int
+parse_config(char *filename, struct aprsd_config *xconf)
+{
+	struct sym	*sym, *next;
+
+	/*if ((conf = calloc(1, sizeof(struct beacon_config))) == NULL)
+		err(1, "calloc");*/
+
+	conf = xconf;
+
+	lineno = 1;
+	errors = 0;
+
+	if (strcmp(filename, "-") == 0) {
+		fin = stdin;
+		infile = "stdin";
+	} else {
+		if ((fin = fopen(filename, "r")) == NULL) {
+			warn("%s", filename);
+			return (1);
+		}
+		infile = filename;
+	}
+
+	yyparse();
+
+	/* Free macros and check which have not been used. */
+	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
+		next = TAILQ_NEXT(sym, entries);
+		if (!sym->used)
+			fprintf(stderr, "warning: macro '%s' not "
+			    "used\n", sym->nam);
+		if (!sym->persist) {
+			free(sym->nam);
+			free(sym->val);
+			TAILQ_REMOVE(&symhead, sym, entries);
+			free(sym);
+		}
+	}
+
+	/* TODO: we would merge the configs and free the local one here */
+
+	return (errors ? -1 : 0);
+}
+
+int
+symset(const char *nam, const char *val, int persist)
+{
+	struct sym	*sym;
+
+	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
+	    sym = TAILQ_NEXT(sym, entries))
+		;	/* nothing */
+
+	if (sym != NULL) {
+		if (sym->persist == 1)
+			return (0);
+		else {
+			free(sym->nam);
+			free(sym->val);
+			TAILQ_REMOVE(&symhead, sym, entries);
+			free(sym);
+		}
+	}
+	if ((sym = calloc(1, sizeof(*sym))) == NULL)
+		return (-1);
+
+	sym->nam = strdup(nam);
+	if (sym->nam == NULL) {
+		free(sym);
+		return (-1);
+	}
+	sym->val = strdup(val);
+	if (sym->val == NULL) {
+		free(sym->nam);
+		free(sym);
+		return (-1);
+	}
+	sym->used = 0;
+	sym->persist = persist;
+	TAILQ_INSERT_TAIL(&symhead, sym, entries);
+	return (0);
+}
+
+int
+cmdline_symset(char *s)
+{
+	char	*sym, *val;
+	int	 ret;
+
+	if ((val = strrchr(s, '=')) == NULL)
+		return (-1);
+
+	if ((sym = malloc(strlen(s) - strlen(val) + 1)) == NULL)
+		err(1, "cmdline_symset: malloc");
+
+	strlcpy(sym, s, strlen(s) - strlen(val) + 1);
+
+	ret = symset(sym, val + 1, 1);
+	free(sym);
+
+	return (ret);
+}
+
+char *
+symget(const char *nam)
+{
+	struct sym	*sym;
+
+	TAILQ_FOREACH(sym, &symhead, entries)
+		if (strcmp(nam, sym->nam) == 0) {
+			sym->used = 1;
+			return (sym->val);
+		}
+	return (NULL);
+}
+
+int
+atoul(char *s, u_long *ulvalp)
+{
+	u_long	 ulval;
+	char	*ep;
+
+	errno = 0;
+	ulval = strtoul(s, &ep, 0);
+	if (s[0] == '\0' || *ep != '\0')
+		return (-1);
+	if (errno == ERANGE && ulval == ULONG_MAX)
+		return (-1);
+	*ulvalp = ulval;
+	return (0);
+}
-- 
2.23.0

